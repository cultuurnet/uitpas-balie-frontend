/**
 * Generated by orval v8.5.0 üç∫
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Error,
  ForbiddenResponse,
  GetTariffsParams,
  GetTariffsStaticParams,
  GetTicketSalesParams,
  TariffsResponse,
  TicketSale,
  TicketSalesPaginatedResponse,
  UnauthorizedResponse
} from '.././model';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * Returns the possible UiTPAS discounted **tariffs for an event and a passholder**.

This UiTPAS tariffs are calculated based on:

- **The regular price** of the ticket.
This is the price your user would have to pay for the specific ticket without UiTPAS discount.
- **The UiTPAS number** of the passholder. UiTPAS discounts are personal so it's important to identify the passholder to retrieve a list of possible tariffs.
- **The event id** of the UiTdatabank event. UiTPAS discounts are limited to specific UiTdatabank events, so it's important to specify the event id to retrieve a list of possible tariffs.

> ##### Important
> The regular price of the ticket should generally be one of the price categories set on the event in UiTdatabank to make financial reporting clearer.

The caller of this request must have `TARIFFS_READ` permission for the organizer of the given event.
 * @summary Get tariffs
 */
export type getTariffsResponse200 = {
  data: TariffsResponse
  status: 200
}

export type getTariffsResponse400 = {
  data: Error
  status: 400
}

export type getTariffsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getTariffsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getTariffsResponseSuccess = (getTariffsResponse200) & {
  headers: Headers;
};
export type getTariffsResponseError = (getTariffsResponse400 | getTariffsResponse401 | getTariffsResponse403) & {
  headers: Headers;
};

export type getTariffsResponse = (getTariffsResponseSuccess | getTariffsResponseError)

export const getGetTariffsUrl = (params: GetTariffsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/tariffs?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/tariffs`
}

export const getTariffs = async (params: GetTariffsParams, options?: RequestInit): Promise<getTariffsResponse> => {
  
  const res = await fetch(getGetTariffsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTariffsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTariffsResponse
}
  




export const getGetTariffsQueryKey = (params?: GetTariffsParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/tariffs`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetTariffsQueryOptions = <TData = Awaited<ReturnType<typeof getTariffs>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(params: GetTariffsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffs>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTariffsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTariffs>>> = ({ signal }) => getTariffs(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTariffs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTariffsQueryResult = NonNullable<Awaited<ReturnType<typeof getTariffs>>>
export type GetTariffsQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetTariffs<TData = Awaited<ReturnType<typeof getTariffs>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTariffs>>,
          TError,
          Awaited<ReturnType<typeof getTariffs>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTariffs<TData = Awaited<ReturnType<typeof getTariffs>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTariffs>>,
          TError,
          Awaited<ReturnType<typeof getTariffs>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTariffs<TData = Awaited<ReturnType<typeof getTariffs>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffs>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get tariffs
 */

export function useGetTariffs<TData = Awaited<ReturnType<typeof getTariffs>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffs>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTariffsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns the **static** UiTPAS discounted **tariffs for an event**.
    
<!-- theme: warning -->
    
> ##### Important
> UiTPAS tariffs are different for each indiviual passholder, but this endpoint does NOT take the passholder into consideration. Use this endpoint only in specific cases, e.g. when listing the UiTPAS tariff before the passholder is known. The actual passholder tariffs might be different than this response. Use [GET /tariffs](/reference/uitpas.json/paths/~1tariffs/get) to retrieve indidivual tariffs for a passholder.
  

This UiTPAS tariffs are calculated based on:

- **The regular price** of the ticket.
This is the price your user would have to pay for the specific ticket without UiTPAS discount.
- **The event id** of the UiTdatabank event. UiTPAS discounts are limited to specific UiTdatabank events, so it's important to specify the event id to retrieve a list of possible tariffs.

Because the passholder is unknown, UiTPAS will return the tariffs for a passholder with social tariff, who lives in the same region as the event organizer.

The caller of this request must have `TARIFFS_READ` permission for the organizer of the given event.
 * @summary Get static tariffs without passholder
 */
export type getTariffsStaticResponse200 = {
  data: TariffsResponse
  status: 200
}

export type getTariffsStaticResponse400 = {
  data: Error
  status: 400
}

export type getTariffsStaticResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getTariffsStaticResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getTariffsStaticResponseSuccess = (getTariffsStaticResponse200) & {
  headers: Headers;
};
export type getTariffsStaticResponseError = (getTariffsStaticResponse400 | getTariffsStaticResponse401 | getTariffsStaticResponse403) & {
  headers: Headers;
};

export type getTariffsStaticResponse = (getTariffsStaticResponseSuccess | getTariffsStaticResponseError)

export const getGetTariffsStaticUrl = (params: GetTariffsStaticParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/tariffs/static?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/tariffs/static`
}

export const getTariffsStatic = async (params: GetTariffsStaticParams, options?: RequestInit): Promise<getTariffsStaticResponse> => {
  
  const res = await fetch(getGetTariffsStaticUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTariffsStaticResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTariffsStaticResponse
}
  




export const getGetTariffsStaticQueryKey = (params?: GetTariffsStaticParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/tariffs/static`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetTariffsStaticQueryOptions = <TData = Awaited<ReturnType<typeof getTariffsStatic>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(params: GetTariffsStaticParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffsStatic>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTariffsStaticQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTariffsStatic>>> = ({ signal }) => getTariffsStatic(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTariffsStatic>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTariffsStaticQueryResult = NonNullable<Awaited<ReturnType<typeof getTariffsStatic>>>
export type GetTariffsStaticQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetTariffsStatic<TData = Awaited<ReturnType<typeof getTariffsStatic>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsStaticParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffsStatic>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTariffsStatic>>,
          TError,
          Awaited<ReturnType<typeof getTariffsStatic>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTariffsStatic<TData = Awaited<ReturnType<typeof getTariffsStatic>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsStaticParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffsStatic>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTariffsStatic>>,
          TError,
          Awaited<ReturnType<typeof getTariffsStatic>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTariffsStatic<TData = Awaited<ReturnType<typeof getTariffsStatic>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsStaticParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffsStatic>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get static tariffs without passholder
 */

export function useGetTariffsStatic<TData = Awaited<ReturnType<typeof getTariffsStatic>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTariffsStaticParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTariffsStatic>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTariffsStaticQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Registers one or more new ticket sales **with a discounted UiTPAS tariff**, so the UiTPAS organiser can get reimbursed for the discount.

Before you can register a discounted ticket sale, you will need to request the possible discounted tariffs from the `GET /tariffs` endpoint and let your end user pick one of the available tariffs. Afterward, you can register a ticket sale using this endpoint. 

You will need:

- The `uitpasNumber` of the passholder buying the ticket.
- The `eventId` of the UiTdatabank event.
- The chosen `tariff` from the `GET /tariffs` request. (only the `id` is required)
- The `regularPrice` the passholder would normally have to pay for this ticket

Optionally you can include:
- a `regularPriceLabel` describing the regular price if you have multiple price 
categories, which can be useful in the financial reporting overview.

If you want to register more than one ticket sale for the same passholder, for the same event, at the same tariff, use multiple `TicketSale` objects in this request. Do note this is only possible if `remaining` was higher than one in the `GET /tariffs` request.

The `passholder` field of `TicketSale` is ignored in the request body. It is included in the response if applicable (passholder can be empty in some cases, e.g. for group passes), but only if the caller of this request has `PASSHOLDERS_SEARCH` permission.

<!-- theme: warning -->

> ##### Error handling
> **If one of the ticket sales is invalid** (for example the chosen tariff is incorrect or expired), **none of the ticket sales will be registered**. You will instead get an error response with more details about the problem, and can then retry the registration without the incorrect ticket sales or ask the end user to change the tickets and/or tariffs that they want.

The caller of this request must have `TICKETSALES_REGISTER`  permission for the organizer of the given event.

 * @summary Register ticket sale(s)
 */
export type postTicketSalesResponse200 = {
  data: TicketSale[]
  status: 200
}

export type postTicketSalesResponse400 = {
  data: Error
  status: 400
}

export type postTicketSalesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type postTicketSalesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type postTicketSalesResponseSuccess = (postTicketSalesResponse200) & {
  headers: Headers;
};
export type postTicketSalesResponseError = (postTicketSalesResponse400 | postTicketSalesResponse401 | postTicketSalesResponse403) & {
  headers: Headers;
};

export type postTicketSalesResponse = (postTicketSalesResponseSuccess | postTicketSalesResponseError)

export const getPostTicketSalesUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/ticket-sales`
}

export const postTicketSales = async (ticketSale: NonReadonly<TicketSale[]>, options?: RequestInit): Promise<postTicketSalesResponse> => {
  
  const res = await fetch(getPostTicketSalesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ticketSale,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postTicketSalesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postTicketSalesResponse
}
  



export const getPostTicketSalesMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTicketSales>>, TError,{data: NonReadonly<TicketSale[]>}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postTicketSales>>, TError,{data: NonReadonly<TicketSale[]>}, TContext> => {

const mutationKey = ['postTicketSales'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTicketSales>>, {data: NonReadonly<TicketSale[]>}> = (props) => {
          const {data} = props ?? {};

          return  postTicketSales(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTicketSalesMutationResult = NonNullable<Awaited<ReturnType<typeof postTicketSales>>>
    export type PostTicketSalesMutationBody = NonReadonly<TicketSale[]>
    export type PostTicketSalesMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Register ticket sale(s)
 */
export const usePostTicketSales = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTicketSales>>, TError,{data: NonReadonly<TicketSale[]>}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTicketSales>>,
        TError,
        {data: NonReadonly<TicketSale[]>},
        TContext
      > => {
      return useMutation(getPostTicketSalesMutationOptions(options), queryClient);
    }
    /**
 * Retrieve ticket sales based on search parameters.

The caller of this request must have `TICKETSALES_SEARCH` permission for the organizer of the given event.

The `passholder` is included in the response if applicable (passholder can be empty in some cases, e.g. for group passes), and only if the caller of this request has PASSHOLDERS_SEARCH permission.
 * @summary Retrieve existing ticket sales
 */
export type getTicketSalesResponse200 = {
  data: TicketSalesPaginatedResponse
  status: 200
}

export type getTicketSalesResponse400 = {
  data: Error
  status: 400
}

export type getTicketSalesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getTicketSalesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getTicketSalesResponseSuccess = (getTicketSalesResponse200) & {
  headers: Headers;
};
export type getTicketSalesResponseError = (getTicketSalesResponse400 | getTicketSalesResponse401 | getTicketSalesResponse403) & {
  headers: Headers;
};

export type getTicketSalesResponse = (getTicketSalesResponseSuccess | getTicketSalesResponseError)

export const getGetTicketSalesUrl = (params: GetTicketSalesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/ticket-sales?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/ticket-sales`
}

export const getTicketSales = async (params: GetTicketSalesParams, options?: RequestInit): Promise<getTicketSalesResponse> => {
  
  const res = await fetch(getGetTicketSalesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTicketSalesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTicketSalesResponse
}
  




export const getGetTicketSalesQueryKey = (params?: GetTicketSalesParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/ticket-sales`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetTicketSalesQueryOptions = <TData = Awaited<ReturnType<typeof getTicketSales>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(params: GetTicketSalesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTicketSales>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTicketSalesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTicketSales>>> = ({ signal }) => getTicketSales(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTicketSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTicketSalesQueryResult = NonNullable<Awaited<ReturnType<typeof getTicketSales>>>
export type GetTicketSalesQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetTicketSales<TData = Awaited<ReturnType<typeof getTicketSales>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTicketSalesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTicketSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTicketSales>>,
          TError,
          Awaited<ReturnType<typeof getTicketSales>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTicketSales<TData = Awaited<ReturnType<typeof getTicketSales>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTicketSalesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTicketSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTicketSales>>,
          TError,
          Awaited<ReturnType<typeof getTicketSales>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTicketSales<TData = Awaited<ReturnType<typeof getTicketSales>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTicketSalesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTicketSales>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve existing ticket sales
 */

export function useGetTicketSales<TData = Awaited<ReturnType<typeof getTicketSales>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: GetTicketSalesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTicketSales>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTicketSalesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Cancels a single ticket sale registration by its id. (Returned in the response of the ticket sale registration request.)

The caller of this request must have `TICKETSALES_REGISTER` permission for the organizer of the event of the ticketsale.
 * @summary Cancel a ticket sale registration
 */
export type deleteTicketSalesResponse204 = {
  data: void
  status: 204
}

export type deleteTicketSalesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteTicketSalesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteTicketSalesResponse404 = {
  data: Error
  status: 404
}

export type deleteTicketSalesResponseSuccess = (deleteTicketSalesResponse204) & {
  headers: Headers;
};
export type deleteTicketSalesResponseError = (deleteTicketSalesResponse401 | deleteTicketSalesResponse403 | deleteTicketSalesResponse404) & {
  headers: Headers;
};

export type deleteTicketSalesResponse = (deleteTicketSalesResponseSuccess | deleteTicketSalesResponseError)

export const getDeleteTicketSalesUrl = (ticketSaleId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/ticket-sales/${ticketSaleId}`
}

export const deleteTicketSales = async (ticketSaleId: string, options?: RequestInit): Promise<deleteTicketSalesResponse> => {
  
  const res = await fetch(getDeleteTicketSalesUrl(ticketSaleId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteTicketSalesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteTicketSalesResponse
}
  



export const getDeleteTicketSalesMutationOptions = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTicketSales>>, TError,{ticketSaleId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTicketSales>>, TError,{ticketSaleId: string}, TContext> => {

const mutationKey = ['deleteTicketSales'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTicketSales>>, {ticketSaleId: string}> = (props) => {
          const {ticketSaleId} = props ?? {};

          return  deleteTicketSales(ticketSaleId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTicketSalesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTicketSales>>>
    
    export type DeleteTicketSalesMutationError = UnauthorizedResponse | ForbiddenResponse | Error

    /**
 * @summary Cancel a ticket sale registration
 */
export const useDeleteTicketSales = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTicketSales>>, TError,{ticketSaleId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTicketSales>>,
        TError,
        {ticketSaleId: string},
        TContext
      > => {
      return useMutation(getDeleteTicketSalesMutationOptions(options), queryClient);
    }
    