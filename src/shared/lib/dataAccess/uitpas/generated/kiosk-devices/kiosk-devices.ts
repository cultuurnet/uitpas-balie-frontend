/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Error,
  ForbiddenResponse,
  KioskDevice,
  KioskDeviceCheckinRequest,
  KioskDeviceCheckinResponse,
  KioskDeviceEvent,
  KioskDeviceEventRequest,
  KioskDeviceSetup,
  KioskPass,
  UnauthorizedResponse
} from '.././model';





/**
 * Configure new kiosk device by looking it up by name and storing the provided device id. After this endpoint has been invoked, the other kiosk APIs can be used with the newly configured device id as `x-custom-token`.

In case no kiosk is found or the kiosk was already setup an error is returned:

* https://api.publiq.be/probs/uitpas/kiosk-not-found
* https://api.publiq.be/probs/uitpas/kiosk-already-configured

The **configuration code** of the device must be specicied in the `x-custom-token` header. This endpoint is rate limited to prevent abuse.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Setup new kiosk device
 */
export type putKiosksSetupResponse200 = {
  data: KioskDevice
  status: 200
}

export type putKiosksSetupResponse400 = {
  data: Error
  status: 400
}

export type putKiosksSetupResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type putKiosksSetupResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type putKiosksSetupResponseSuccess = (putKiosksSetupResponse200) & {
  headers: Headers;
};
export type putKiosksSetupResponseError = (putKiosksSetupResponse400 | putKiosksSetupResponse401 | putKiosksSetupResponse403) & {
  headers: Headers;
};

export type putKiosksSetupResponse = (putKiosksSetupResponseSuccess | putKiosksSetupResponseError)

export const getPutKiosksSetupUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices/setup`
}

export const putKiosksSetup = async (kioskDeviceSetup: KioskDeviceSetup, options?: RequestInit): Promise<putKiosksSetupResponse> => {
  
  const res = await fetch(getPutKiosksSetupUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      kioskDeviceSetup,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putKiosksSetupResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putKiosksSetupResponse
}




export const getPutKiosksSetupMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putKiosksSetup>>, TError,{data: KioskDeviceSetup}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putKiosksSetup>>, TError,{data: KioskDeviceSetup}, TContext> => {

const mutationKey = ['putKiosksSetup'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putKiosksSetup>>, {data: KioskDeviceSetup}> = (props) => {
          const {data} = props ?? {};

          return  putKiosksSetup(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutKiosksSetupMutationResult = NonNullable<Awaited<ReturnType<typeof putKiosksSetup>>>
    export type PutKiosksSetupMutationBody = KioskDeviceSetup
    export type PutKiosksSetupMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Setup new kiosk device
 */
export const usePutKiosksSetup = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putKiosksSetup>>, TError,{data: KioskDeviceSetup}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putKiosksSetup>>,
        TError,
        {data: KioskDeviceSetup},
        TContext
      > => {
      return useMutation(getPutKiosksSetupMutationOptions(options), queryClient);
    }
    /**
 * Retrieve current kiosk.

The device id of the kiosk must be specicied in the `x-custom-token` header.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Retrieve kiosk
 */
export type getKiosksResponse200 = {
  data: KioskDevice
  status: 200
}

export type getKiosksResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getKiosksResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type getKiosksResponseSuccess = (getKiosksResponse200) & {
  headers: Headers;
};
export type getKiosksResponseError = (getKiosksResponse401 | getKiosksResponse403) & {
  headers: Headers;
};

export type getKiosksResponse = (getKiosksResponseSuccess | getKiosksResponseError)

export const getGetKiosksUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices`
}

export const getKiosks = async ( options?: RequestInit): Promise<getKiosksResponse> => {
  
  const res = await fetch(getGetKiosksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getKiosksResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getKiosksResponse
}





export const getGetKiosksQueryKey = () => {
    return [
    `NEXT_PUBLIC_API_PATH/kiosk-devices`
    ] as const;
    }

    
export const getGetKiosksQueryOptions = <TData = Awaited<ReturnType<typeof getKiosks>>, TError = UnauthorizedResponse | ForbiddenResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosks>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetKiosksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getKiosks>>> = ({ signal }) => getKiosks({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getKiosks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetKiosksQueryResult = NonNullable<Awaited<ReturnType<typeof getKiosks>>>
export type GetKiosksQueryError = UnauthorizedResponse | ForbiddenResponse


export function useGetKiosks<TData = Awaited<ReturnType<typeof getKiosks>>, TError = UnauthorizedResponse | ForbiddenResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosks>>,
          TError,
          Awaited<ReturnType<typeof getKiosks>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosks<TData = Awaited<ReturnType<typeof getKiosks>>, TError = UnauthorizedResponse | ForbiddenResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosks>>,
          TError,
          Awaited<ReturnType<typeof getKiosks>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosks<TData = Awaited<ReturnType<typeof getKiosks>>, TError = UnauthorizedResponse | ForbiddenResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosks>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve kiosk
 */

export function useGetKiosks<TData = Awaited<ReturnType<typeof getKiosks>>, TError = UnauthorizedResponse | ForbiddenResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosks>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetKiosksQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve the configured event of the kiosk.

This is a configuration endpoint, if you need to retrieve the **current** event, please use `GET /kiosk-devices/checkins`

The device id of the kiosk must be specicied in the `x-custom-token` header.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Retrieve configured event
 */
export type getKiosksEventResponse200 = {
  data: KioskDeviceEvent
  status: 200
}

export type getKiosksEventResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getKiosksEventResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getKiosksEventResponse404 = {
  data: Error
  status: 404
}
    
export type getKiosksEventResponseSuccess = (getKiosksEventResponse200) & {
  headers: Headers;
};
export type getKiosksEventResponseError = (getKiosksEventResponse401 | getKiosksEventResponse403 | getKiosksEventResponse404) & {
  headers: Headers;
};

export type getKiosksEventResponse = (getKiosksEventResponseSuccess | getKiosksEventResponseError)

export const getGetKiosksEventUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices/events`
}

export const getKiosksEvent = async ( options?: RequestInit): Promise<getKiosksEventResponse> => {
  
  const res = await fetch(getGetKiosksEventUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getKiosksEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getKiosksEventResponse
}





export const getGetKiosksEventQueryKey = () => {
    return [
    `NEXT_PUBLIC_API_PATH/kiosk-devices/events`
    ] as const;
    }

    
export const getGetKiosksEventQueryOptions = <TData = Awaited<ReturnType<typeof getKiosksEvent>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksEvent>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetKiosksEventQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getKiosksEvent>>> = ({ signal }) => getKiosksEvent({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getKiosksEvent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetKiosksEventQueryResult = NonNullable<Awaited<ReturnType<typeof getKiosksEvent>>>
export type GetKiosksEventQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetKiosksEvent<TData = Awaited<ReturnType<typeof getKiosksEvent>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksEvent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosksEvent>>,
          TError,
          Awaited<ReturnType<typeof getKiosksEvent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosksEvent<TData = Awaited<ReturnType<typeof getKiosksEvent>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksEvent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosksEvent>>,
          TError,
          Awaited<ReturnType<typeof getKiosksEvent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosksEvent<TData = Awaited<ReturnType<typeof getKiosksEvent>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksEvent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve configured event
 */

export function useGetKiosksEvent<TData = Awaited<ReturnType<typeof getKiosksEvent>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksEvent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetKiosksEventQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update the current event of the kiosk.

The device id of the kiosk must be specicied in the `x-custom-token` header.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Configure event
 */
export type putKiosksEventsResponse204 = {
  data: void
  status: 204
}

export type putKiosksEventsResponse400 = {
  data: Error
  status: 400
}

export type putKiosksEventsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type putKiosksEventsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type putKiosksEventsResponseSuccess = (putKiosksEventsResponse204) & {
  headers: Headers;
};
export type putKiosksEventsResponseError = (putKiosksEventsResponse400 | putKiosksEventsResponse401 | putKiosksEventsResponse403) & {
  headers: Headers;
};

export type putKiosksEventsResponse = (putKiosksEventsResponseSuccess | putKiosksEventsResponseError)

export const getPutKiosksEventsUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices/events`
}

export const putKiosksEvents = async (kioskDeviceEventRequest: KioskDeviceEventRequest, options?: RequestInit): Promise<putKiosksEventsResponse> => {
  
  const res = await fetch(getPutKiosksEventsUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      kioskDeviceEventRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putKiosksEventsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putKiosksEventsResponse
}




export const getPutKiosksEventsMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putKiosksEvents>>, TError,{data: KioskDeviceEventRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putKiosksEvents>>, TError,{data: KioskDeviceEventRequest}, TContext> => {

const mutationKey = ['putKiosksEvents'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putKiosksEvents>>, {data: KioskDeviceEventRequest}> = (props) => {
          const {data} = props ?? {};

          return  putKiosksEvents(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutKiosksEventsMutationResult = NonNullable<Awaited<ReturnType<typeof putKiosksEvents>>>
    export type PutKiosksEventsMutationBody = KioskDeviceEventRequest
    export type PutKiosksEventsMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Configure event
 */
export const usePutKiosksEvents = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putKiosksEvents>>, TError,{data: KioskDeviceEventRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putKiosksEvents>>,
        TError,
        {data: KioskDeviceEventRequest},
        TContext
      > => {
      return useMutation(getPutKiosksEventsMutationOptions(options), queryClient);
    }
    /**
 * Delete configured event

The device id of the kiosk must be specicied in the `x-custom-token` header.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Delete configured event
 */
export type deleteKiosksEventsResponse204 = {
  data: void
  status: 204
}

export type deleteKiosksEventsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteKiosksEventsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type deleteKiosksEventsResponseSuccess = (deleteKiosksEventsResponse204) & {
  headers: Headers;
};
export type deleteKiosksEventsResponseError = (deleteKiosksEventsResponse401 | deleteKiosksEventsResponse403) & {
  headers: Headers;
};

export type deleteKiosksEventsResponse = (deleteKiosksEventsResponseSuccess | deleteKiosksEventsResponseError)

export const getDeleteKiosksEventsUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices/events`
}

export const deleteKiosksEvents = async ( options?: RequestInit): Promise<deleteKiosksEventsResponse> => {
  
  const res = await fetch(getDeleteKiosksEventsUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteKiosksEventsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteKiosksEventsResponse
}




export const getDeleteKiosksEventsMutationOptions = <TError = UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteKiosksEvents>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteKiosksEvents>>, TError,void, TContext> => {

const mutationKey = ['deleteKiosksEvents'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteKiosksEvents>>, void> = () => {
          

          return  deleteKiosksEvents(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteKiosksEventsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteKiosksEvents>>>
    
    export type DeleteKiosksEventsMutationError = UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Delete configured event
 */
export const useDeleteKiosksEvents = <TError = UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteKiosksEvents>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteKiosksEvents>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getDeleteKiosksEventsMutationOptions(options), queryClient);
    }
    /**
 * Checkin a passholder with the given NFC chipnumber at the kiosk.

The device id of the kiosk must be specicied in the `x-custom-token` header.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Checkin passholder via kiosk
 */
export type postKiosksCheckinResponse200 = {
  data: KioskDeviceCheckinResponse
  status: 200
}

export type postKiosksCheckinResponse400 = {
  data: Error
  status: 400
}

export type postKiosksCheckinResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type postKiosksCheckinResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type postKiosksCheckinResponseSuccess = (postKiosksCheckinResponse200) & {
  headers: Headers;
};
export type postKiosksCheckinResponseError = (postKiosksCheckinResponse400 | postKiosksCheckinResponse401 | postKiosksCheckinResponse403) & {
  headers: Headers;
};

export type postKiosksCheckinResponse = (postKiosksCheckinResponseSuccess | postKiosksCheckinResponseError)

export const getPostKiosksCheckinUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices/checkins`
}

export const postKiosksCheckin = async (kioskDeviceCheckinRequest: KioskDeviceCheckinRequest, options?: RequestInit): Promise<postKiosksCheckinResponse> => {
  
  const res = await fetch(getPostKiosksCheckinUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      kioskDeviceCheckinRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postKiosksCheckinResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postKiosksCheckinResponse
}




export const getPostKiosksCheckinMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postKiosksCheckin>>, TError,{data: KioskDeviceCheckinRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postKiosksCheckin>>, TError,{data: KioskDeviceCheckinRequest}, TContext> => {

const mutationKey = ['postKiosksCheckin'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postKiosksCheckin>>, {data: KioskDeviceCheckinRequest}> = (props) => {
          const {data} = props ?? {};

          return  postKiosksCheckin(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostKiosksCheckinMutationResult = NonNullable<Awaited<ReturnType<typeof postKiosksCheckin>>>
    export type PostKiosksCheckinMutationBody = KioskDeviceCheckinRequest
    export type PostKiosksCheckinMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Checkin passholder via kiosk
 */
export const usePostKiosksCheckin = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postKiosksCheckin>>, TError,{data: KioskDeviceCheckinRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postKiosksCheckin>>,
        TError,
        {data: KioskDeviceCheckinRequest},
        TContext
      > => {
      return useMutation(getPostKiosksCheckinMutationOptions(options), queryClient);
    }
    /**
 * Retrieve the current event of the kiosk. When returned, checkin on this kiosk and event is allowed.

The following logic is being used to determine the current checkin event:
* is the event configured and is checkin currently allowed for that event? then use this event.
* otherwise, the most suitable event is autodetected based on the organizers and locations of the kiosk.

The device id of the kiosk must be specicied in the `x-custom-token` header.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Retrieve the current checkin event
 */
export type getKiosksCheckinsResponse200 = {
  data: KioskDeviceEvent
  status: 200
}

export type getKiosksCheckinsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getKiosksCheckinsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getKiosksCheckinsResponse404 = {
  data: Error
  status: 404
}
    
export type getKiosksCheckinsResponseSuccess = (getKiosksCheckinsResponse200) & {
  headers: Headers;
};
export type getKiosksCheckinsResponseError = (getKiosksCheckinsResponse401 | getKiosksCheckinsResponse403 | getKiosksCheckinsResponse404) & {
  headers: Headers;
};

export type getKiosksCheckinsResponse = (getKiosksCheckinsResponseSuccess | getKiosksCheckinsResponseError)

export const getGetKiosksCheckinsUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices/checkins`
}

export const getKiosksCheckins = async ( options?: RequestInit): Promise<getKiosksCheckinsResponse> => {
  
  const res = await fetch(getGetKiosksCheckinsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getKiosksCheckinsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getKiosksCheckinsResponse
}





export const getGetKiosksCheckinsQueryKey = () => {
    return [
    `NEXT_PUBLIC_API_PATH/kiosk-devices/checkins`
    ] as const;
    }

    
export const getGetKiosksCheckinsQueryOptions = <TData = Awaited<ReturnType<typeof getKiosksCheckins>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksCheckins>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetKiosksCheckinsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getKiosksCheckins>>> = ({ signal }) => getKiosksCheckins({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getKiosksCheckins>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetKiosksCheckinsQueryResult = NonNullable<Awaited<ReturnType<typeof getKiosksCheckins>>>
export type GetKiosksCheckinsQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetKiosksCheckins<TData = Awaited<ReturnType<typeof getKiosksCheckins>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksCheckins>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosksCheckins>>,
          TError,
          Awaited<ReturnType<typeof getKiosksCheckins>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosksCheckins<TData = Awaited<ReturnType<typeof getKiosksCheckins>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksCheckins>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosksCheckins>>,
          TError,
          Awaited<ReturnType<typeof getKiosksCheckins>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosksCheckins<TData = Awaited<ReturnType<typeof getKiosksCheckins>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksCheckins>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve the current checkin event
 */

export function useGetKiosksCheckins<TData = Awaited<ReturnType<typeof getKiosksCheckins>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksCheckins>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetKiosksCheckinsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve total points of a passholder by chip number.

The device id of the kiosk must be specicied in the `x-custom-token` header.

<!-- theme: warning -->

> **This endpoint is exclusively for use by Kiosk devices themselves**. It cannot be used by other applications to manage the device.
 * @summary Retrieve total points of a passholder by chip number
 */
export type getKiosksChipNumbersChipNumberResponse200 = {
  data: KioskPass
  status: 200
}

export type getKiosksChipNumbersChipNumberResponse400 = {
  data: Error
  status: 400
}

export type getKiosksChipNumbersChipNumberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getKiosksChipNumbersChipNumberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getKiosksChipNumbersChipNumberResponse404 = {
  data: Error
  status: 404
}
    
export type getKiosksChipNumbersChipNumberResponseSuccess = (getKiosksChipNumbersChipNumberResponse200) & {
  headers: Headers;
};
export type getKiosksChipNumbersChipNumberResponseError = (getKiosksChipNumbersChipNumberResponse400 | getKiosksChipNumbersChipNumberResponse401 | getKiosksChipNumbersChipNumberResponse403 | getKiosksChipNumbersChipNumberResponse404) & {
  headers: Headers;
};

export type getKiosksChipNumbersChipNumberResponse = (getKiosksChipNumbersChipNumberResponseSuccess | getKiosksChipNumbersChipNumberResponseError)

export const getGetKiosksChipNumbersChipNumberUrl = (chipNumber: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/kiosk-devices/chip-numbers/${chipNumber}`
}

export const getKiosksChipNumbersChipNumber = async (chipNumber: string, options?: RequestInit): Promise<getKiosksChipNumbersChipNumberResponse> => {
  
  const res = await fetch(getGetKiosksChipNumbersChipNumberUrl(chipNumber),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getKiosksChipNumbersChipNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getKiosksChipNumbersChipNumberResponse
}





export const getGetKiosksChipNumbersChipNumberQueryKey = (chipNumber: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/kiosk-devices/chip-numbers/${chipNumber}`
    ] as const;
    }

    
export const getGetKiosksChipNumbersChipNumberQueryOptions = <TData = Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetKiosksChipNumbersChipNumberQueryKey(chipNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>> = ({ signal }) => getKiosksChipNumbersChipNumber(chipNumber, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chipNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetKiosksChipNumbersChipNumberQueryResult = NonNullable<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>>
export type GetKiosksChipNumbersChipNumberQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetKiosksChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>,
          TError,
          Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosksChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>,
          TError,
          Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetKiosksChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve total points of a passholder by chip number
 */

export function useGetKiosksChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKiosksChipNumbersChipNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetKiosksChipNumbersChipNumberQueryOptions(chipNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




