/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssociationMembership,
  Error,
  ForbiddenResponse,
  GetPassholdersMembershipPricesCardSystemIdParams,
  GetPassholdersParams,
  GetPassholdersPassholderIdAssociationMembershipsParams,
  GetPassholdersPassholderIdMembershipPricesCardSystemIdParams,
  GetPassholdersPassholderIdTransactionsParams,
  MembershipPrice,
  Pass,
  Passholder,
  PassholderPicture,
  PassholdersPaginatedResponse,
  PassholdersStatusInszNumbersInsznumber200,
  PostPassholdersPassholderIdCheckin201,
  PostPassholdersPassholderIdCheckinBody,
  TransactionsPaginatedCollection,
  UnauthorizedResponse
} from '.././model';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * Retrieve passholders based on search parameters.

Note: by default passholders in the response are alphabetically sorted by name.

The caller of this request must have `PASSHOLDERS_SEARCH` or `PASSHOLDERS_SEARCH_BY_ID` or `PASSHOLDERS_SEARCH_ALL` permission. 

In case of `PASSHOLDERS_SEARCH` permission, passholder results are filtered based on the allowed card systems of the caller, unless searched by one of the ID fields:
* `uitpasNumber`
* `chipNumber`
* `inszNumber`
* `uitidId`

In case of `PASSHOLDERS_SEARCH_BY_ID` permission, the caller can only make use of those ID fields.
 * @summary Search passholders
 */
export type getPassholdersResponse200 = {
  data: PassholdersPaginatedResponse
  status: 200
}

export type getPassholdersResponse400 = {
  data: Error
  status: 400
}

export type getPassholdersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersResponseSuccess = (getPassholdersResponse200) & {
  headers: Headers;
};
export type getPassholdersResponseError = (getPassholdersResponse400 | getPassholdersResponse401 | getPassholdersResponse403) & {
  headers: Headers;
};

export type getPassholdersResponse = (getPassholdersResponseSuccess | getPassholdersResponseError)

export const getGetPassholdersUrl = (params?: GetPassholdersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/passholders?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/passholders`
}

export const getPassholders = async (params?: GetPassholdersParams, options?: RequestInit): Promise<getPassholdersResponse> => {
  
  const res = await fetch(getGetPassholdersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersResponse
}
  




export const getGetPassholdersQueryKey = (params?: GetPassholdersParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPassholdersQueryOptions = <TData = Awaited<ReturnType<typeof getPassholders>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(params?: GetPassholdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholders>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholders>>> = ({ signal }) => getPassholders(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholders>>>
export type GetPassholdersQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetPassholders<TData = Awaited<ReturnType<typeof getPassholders>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params: undefined |  GetPassholdersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholders>>,
          TError,
          Awaited<ReturnType<typeof getPassholders>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholders<TData = Awaited<ReturnType<typeof getPassholders>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params?: GetPassholdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholders>>,
          TError,
          Awaited<ReturnType<typeof getPassholders>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholders<TData = Awaited<ReturnType<typeof getPassholders>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params?: GetPassholdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholders>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search passholders
 */

export function useGetPassholders<TData = Awaited<ReturnType<typeof getPassholders>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 params?: GetPassholdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholders>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Register a passholder

<!-- theme: warning -->

> IMPORTANT
>
> Make sure to set `registrationCardType` to either `DIGITAL` or `NFC_CARD`. In case of `NFC_CARD` the field `registrationUitpasNumber` is required and has to be a card in status `LOCAL_STOCK`.

The caller of this request must have `PASSHOLDERS_WRITE` permission for the `registrationOrganizer`.
On top of that `PASSHOLDERS_WRITE_SOCIAL_TARIFF` permission is required for callers that register a passholder with social tariff. And on top of that `PASSHOLDERS_WRITE_SOCIALTARIFF_FULL_CARDSYSTEM` permission is required to register passholders with social tariff in another city than the `registrationOrganizer`.

`PASSHOLDERS_WRITE_FOREIGN_COUNTRY` permission is needed when registering any passholder with a country other than `be`.
 * @summary Register a new passholder
 */
export type postPassholdersResponse200 = {
  data: Passholder
  status: 200
}

export type postPassholdersResponse400 = {
  data: Error
  status: 400
}

export type postPassholdersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type postPassholdersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type postPassholdersResponse404 = {
  data: Error
  status: 404
}

export type postPassholdersResponseSuccess = (postPassholdersResponse200) & {
  headers: Headers;
};
export type postPassholdersResponseError = (postPassholdersResponse400 | postPassholdersResponse401 | postPassholdersResponse403 | postPassholdersResponse404) & {
  headers: Headers;
};

export type postPassholdersResponse = (postPassholdersResponseSuccess | postPassholdersResponseError)

export const getPostPassholdersUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/passholders`
}

export const postPassholders = async (passholder: NonReadonly<Passholder>, options?: RequestInit): Promise<postPassholdersResponse> => {
  
  const res = await fetch(getPostPassholdersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      passholder,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postPassholdersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postPassholdersResponse
}
  



export const getPostPassholdersMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholders>>, TError,{data: NonReadonly<Passholder>}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postPassholders>>, TError,{data: NonReadonly<Passholder>}, TContext> => {

const mutationKey = ['postPassholders'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPassholders>>, {data: NonReadonly<Passholder>}> = (props) => {
          const {data} = props ?? {};

          return  postPassholders(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostPassholdersMutationResult = NonNullable<Awaited<ReturnType<typeof postPassholders>>>
    export type PostPassholdersMutationBody = NonReadonly<Passholder>
    export type PostPassholdersMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Register a new passholder
 */
export const usePostPassholders = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholders>>, TError,{data: NonReadonly<Passholder>}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPassholders>>,
        TError,
        {data: NonReadonly<Passholder>},
        TContext
      > => {
      return useMutation(getPostPassholdersMutationOptions(options), queryClient);
    }
    /**
 * Remove this passholder.

The caller of this request must have `PASSHOLDERS_DELETE` permission.
 * @summary Remove passholder
 */
export type deletePassholdersPassholderIdResponse204 = {
  data: void
  status: 204
}

export type deletePassholdersPassholderIdResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deletePassholdersPassholderIdResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deletePassholdersPassholderIdResponse404 = {
  data: Error
  status: 404
}

export type deletePassholdersPassholderIdResponseSuccess = (deletePassholdersPassholderIdResponse204) & {
  headers: Headers;
};
export type deletePassholdersPassholderIdResponseError = (deletePassholdersPassholderIdResponse401 | deletePassholdersPassholderIdResponse403 | deletePassholdersPassholderIdResponse404) & {
  headers: Headers;
};

export type deletePassholdersPassholderIdResponse = (deletePassholdersPassholderIdResponseSuccess | deletePassholdersPassholderIdResponseError)

export const getDeletePassholdersPassholderIdUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}`
}

export const deletePassholdersPassholderId = async (passholderId: string, options?: RequestInit): Promise<deletePassholdersPassholderIdResponse> => {
  
  const res = await fetch(getDeletePassholdersPassholderIdUrl(passholderId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deletePassholdersPassholderIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deletePassholdersPassholderIdResponse
}
  



export const getDeletePassholdersPassholderIdMutationOptions = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersPassholderId>>, TError,{passholderId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersPassholderId>>, TError,{passholderId: string}, TContext> => {

const mutationKey = ['deletePassholdersPassholderId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePassholdersPassholderId>>, {passholderId: string}> = (props) => {
          const {passholderId} = props ?? {};

          return  deletePassholdersPassholderId(passholderId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePassholdersPassholderIdMutationResult = NonNullable<Awaited<ReturnType<typeof deletePassholdersPassholderId>>>
    
    export type DeletePassholdersPassholderIdMutationError = UnauthorizedResponse | ForbiddenResponse | Error

    /**
 * @summary Remove passholder
 */
export const useDeletePassholdersPassholderId = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersPassholderId>>, TError,{passholderId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePassholdersPassholderId>>,
        TError,
        {passholderId: string},
        TContext
      > => {
      return useMutation(getDeletePassholdersPassholderIdMutationOptions(options), queryClient);
    }
    /**
 * Retrieve picture of the given passholder.

This endpoint allows you to obtain a short-lived link to the picture of the passholder. After generation, this link remains active for a limited time, enabling you to include it in HTML pages displayed to your users.

The caller of this method must have `PASSHOLDERS_PICTURE_READ` permission for the given passholder.
 * @summary Get picture of passholder
 */
export type getPassholdersPassholderIdPictureResponse200 = {
  data: PassholderPicture
  status: 200
}

export type getPassholdersPassholderIdPictureResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersPassholderIdPictureResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersPassholderIdPictureResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersPassholderIdPictureResponseSuccess = (getPassholdersPassholderIdPictureResponse200) & {
  headers: Headers;
};
export type getPassholdersPassholderIdPictureResponseError = (getPassholdersPassholderIdPictureResponse401 | getPassholdersPassholderIdPictureResponse403 | getPassholdersPassholderIdPictureResponse404) & {
  headers: Headers;
};

export type getPassholdersPassholderIdPictureResponse = (getPassholdersPassholderIdPictureResponseSuccess | getPassholdersPassholderIdPictureResponseError)

export const getGetPassholdersPassholderIdPictureUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/picture`
}

export const getPassholdersPassholderIdPicture = async (passholderId: string, options?: RequestInit): Promise<getPassholdersPassholderIdPictureResponse> => {
  
  const res = await fetch(getGetPassholdersPassholderIdPictureUrl(passholderId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersPassholderIdPictureResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersPassholderIdPictureResponse
}
  




export const getGetPassholdersPassholderIdPictureQueryKey = (passholderId: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/picture`
    ] as const;
    }

    
export const getGetPassholdersPassholderIdPictureQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersPassholderIdPictureQueryKey(passholderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>> = ({ signal }) => getPassholdersPassholderIdPicture(passholderId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(passholderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersPassholderIdPictureQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>>
export type GetPassholdersPassholderIdPictureQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetPassholdersPassholderIdPicture<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdPicture<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdPicture<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get picture of passholder
 */

export function useGetPassholdersPassholderIdPicture<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdPicture>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersPassholderIdPictureQueryOptions(passholderId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve association memberships of the given passholder. Only memberships are returned for assocations that are visible to the specified organizer.

The caller of this method must have `ASSOCIATIONS` permission for the given organizer.
 * @summary Get association memberships of passholder
 */
export type getPassholdersPassholderIdAssociationMembershipsResponse200 = {
  data: AssociationMembership[]
  status: 200
}

export type getPassholdersPassholderIdAssociationMembershipsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersPassholderIdAssociationMembershipsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersPassholderIdAssociationMembershipsResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersPassholderIdAssociationMembershipsResponseSuccess = (getPassholdersPassholderIdAssociationMembershipsResponse200) & {
  headers: Headers;
};
export type getPassholdersPassholderIdAssociationMembershipsResponseError = (getPassholdersPassholderIdAssociationMembershipsResponse401 | getPassholdersPassholderIdAssociationMembershipsResponse403 | getPassholdersPassholderIdAssociationMembershipsResponse404) & {
  headers: Headers;
};

export type getPassholdersPassholderIdAssociationMembershipsResponse = (getPassholdersPassholderIdAssociationMembershipsResponseSuccess | getPassholdersPassholderIdAssociationMembershipsResponseError)

export const getGetPassholdersPassholderIdAssociationMembershipsUrl = (passholderId: string,
    params: GetPassholdersPassholderIdAssociationMembershipsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/association-memberships?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/association-memberships`
}

export const getPassholdersPassholderIdAssociationMemberships = async (passholderId: string,
    params: GetPassholdersPassholderIdAssociationMembershipsParams, options?: RequestInit): Promise<getPassholdersPassholderIdAssociationMembershipsResponse> => {
  
  const res = await fetch(getGetPassholdersPassholderIdAssociationMembershipsUrl(passholderId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersPassholderIdAssociationMembershipsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersPassholderIdAssociationMembershipsResponse
}
  




export const getGetPassholdersPassholderIdAssociationMembershipsQueryKey = (passholderId: string,
    params?: GetPassholdersPassholderIdAssociationMembershipsParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/association-memberships`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPassholdersPassholderIdAssociationMembershipsQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(passholderId: string,
    params: GetPassholdersPassholderIdAssociationMembershipsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersPassholderIdAssociationMembershipsQueryKey(passholderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>> = ({ signal }) => getPassholdersPassholderIdAssociationMemberships(passholderId,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(passholderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersPassholderIdAssociationMembershipsQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>>
export type GetPassholdersPassholderIdAssociationMembershipsQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetPassholdersPassholderIdAssociationMemberships<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string,
    params: GetPassholdersPassholderIdAssociationMembershipsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdAssociationMemberships<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string,
    params: GetPassholdersPassholderIdAssociationMembershipsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdAssociationMemberships<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string,
    params: GetPassholdersPassholderIdAssociationMembershipsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get association memberships of passholder
 */

export function useGetPassholdersPassholderIdAssociationMemberships<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string,
    params: GetPassholdersPassholderIdAssociationMembershipsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdAssociationMemberships>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersPassholderIdAssociationMembershipsQueryOptions(passholderId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve the exact membership price for a new passholder. `cardType`, `postalCode` and `dateOfBirth` are mandatory to determine the correct price. `socialTariff` and `voucher` are optional.

To retrieve a list of prices for a card system if not all details are known yet, you can use [GET /card-systems/{cardSystemId}/membership-prices](/reference/uitpas.json/paths/~1card-systems~1{cardSystemId}~1membership-prices/get).

The caller of this request must have `MEMBERSHIP_PRICES_READ` permission.
 * @summary Retrieve new membership price
 */
export type getPassholdersMembershipPricesCardSystemIdResponse200 = {
  data: MembershipPrice
  status: 200
}

export type getPassholdersMembershipPricesCardSystemIdResponse400 = {
  data: Error
  status: 400
}

export type getPassholdersMembershipPricesCardSystemIdResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersMembershipPricesCardSystemIdResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersMembershipPricesCardSystemIdResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersMembershipPricesCardSystemIdResponseSuccess = (getPassholdersMembershipPricesCardSystemIdResponse200) & {
  headers: Headers;
};
export type getPassholdersMembershipPricesCardSystemIdResponseError = (getPassholdersMembershipPricesCardSystemIdResponse400 | getPassholdersMembershipPricesCardSystemIdResponse401 | getPassholdersMembershipPricesCardSystemIdResponse403 | getPassholdersMembershipPricesCardSystemIdResponse404) & {
  headers: Headers;
};

export type getPassholdersMembershipPricesCardSystemIdResponse = (getPassholdersMembershipPricesCardSystemIdResponseSuccess | getPassholdersMembershipPricesCardSystemIdResponseError)

export const getGetPassholdersMembershipPricesCardSystemIdUrl = (cardSystemId: number,
    params: GetPassholdersMembershipPricesCardSystemIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/passholders/membership-prices/${cardSystemId}?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/passholders/membership-prices/${cardSystemId}`
}

export const getPassholdersMembershipPricesCardSystemId = async (cardSystemId: number,
    params: GetPassholdersMembershipPricesCardSystemIdParams, options?: RequestInit): Promise<getPassholdersMembershipPricesCardSystemIdResponse> => {
  
  const res = await fetch(getGetPassholdersMembershipPricesCardSystemIdUrl(cardSystemId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersMembershipPricesCardSystemIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersMembershipPricesCardSystemIdResponse
}
  




export const getGetPassholdersMembershipPricesCardSystemIdQueryKey = (cardSystemId: number,
    params?: GetPassholdersMembershipPricesCardSystemIdParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/membership-prices/${cardSystemId}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPassholdersMembershipPricesCardSystemIdQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(cardSystemId: number,
    params: GetPassholdersMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersMembershipPricesCardSystemIdQueryKey(cardSystemId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>> = ({ signal }) => getPassholdersMembershipPricesCardSystemId(cardSystemId,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(cardSystemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersMembershipPricesCardSystemIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>>
export type GetPassholdersMembershipPricesCardSystemIdQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetPassholdersMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 cardSystemId: number,
    params: GetPassholdersMembershipPricesCardSystemIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 cardSystemId: number,
    params: GetPassholdersMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 cardSystemId: number,
    params: GetPassholdersMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve new membership price
 */

export function useGetPassholdersMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 cardSystemId: number,
    params: GetPassholdersMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMembershipPricesCardSystemId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersMembershipPricesCardSystemIdQueryOptions(cardSystemId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve the exact membership price for an existing passholder in a new card system. `cardType` is mandatory to determine the correct price. `socialTariff` and `voucher` are optional.

To retrieve the price for a *new* passholder, use [GET /passholders/membership-prices/{cardSystemId}](/reference/uitpas.json/paths/~1passholders~1membership-prices~1{cardSystemId}/get).

To retrieve a list of prices for a card system if not all details are known yet, you can use [GET /card-systems/{cardSystemId}/membership-prices](/reference/uitpas.json/paths/~1card-systems~1{cardSystemId}~1membership-prices/get).

The caller of this request must have `PASSHOLDERS_SEARCH` and `MEMBERSHIP_PRICES_READ` permission.
 * @summary Retrieve upgrade membership price
 */
export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponse200 = {
  data: MembershipPrice
  status: 200
}

export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponse400 = {
  data: Error
  status: 400
}

export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponseSuccess = (getPassholdersPassholderIdMembershipPricesCardSystemIdResponse200) & {
  headers: Headers;
};
export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponseError = (getPassholdersPassholderIdMembershipPricesCardSystemIdResponse400 | getPassholdersPassholderIdMembershipPricesCardSystemIdResponse401 | getPassholdersPassholderIdMembershipPricesCardSystemIdResponse403 | getPassholdersPassholderIdMembershipPricesCardSystemIdResponse404) & {
  headers: Headers;
};

export type getPassholdersPassholderIdMembershipPricesCardSystemIdResponse = (getPassholdersPassholderIdMembershipPricesCardSystemIdResponseSuccess | getPassholdersPassholderIdMembershipPricesCardSystemIdResponseError)

export const getGetPassholdersPassholderIdMembershipPricesCardSystemIdUrl = (passholderId: string,
    cardSystemId: number,
    params: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/membership-prices/${cardSystemId}?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/membership-prices/${cardSystemId}`
}

export const getPassholdersPassholderIdMembershipPricesCardSystemId = async (passholderId: string,
    cardSystemId: number,
    params: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams, options?: RequestInit): Promise<getPassholdersPassholderIdMembershipPricesCardSystemIdResponse> => {
  
  const res = await fetch(getGetPassholdersPassholderIdMembershipPricesCardSystemIdUrl(passholderId,cardSystemId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersPassholderIdMembershipPricesCardSystemIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersPassholderIdMembershipPricesCardSystemIdResponse
}
  




export const getGetPassholdersPassholderIdMembershipPricesCardSystemIdQueryKey = (passholderId: string,
    cardSystemId: number,
    params?: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/membership-prices/${cardSystemId}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPassholdersPassholderIdMembershipPricesCardSystemIdQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(passholderId: string,
    cardSystemId: number,
    params: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersPassholderIdMembershipPricesCardSystemIdQueryKey(passholderId,cardSystemId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>> = ({ signal }) => getPassholdersPassholderIdMembershipPricesCardSystemId(passholderId,cardSystemId,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(passholderId && cardSystemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersPassholderIdMembershipPricesCardSystemIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>>
export type GetPassholdersPassholderIdMembershipPricesCardSystemIdQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetPassholdersPassholderIdMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    cardSystemId: number,
    params: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    cardSystemId: number,
    params: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    cardSystemId: number,
    params: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve upgrade membership price
 */

export function useGetPassholdersPassholderIdMembershipPricesCardSystemId<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    cardSystemId: number,
    params: GetPassholdersPassholderIdMembershipPricesCardSystemIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdMembershipPricesCardSystemId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersPassholderIdMembershipPricesCardSystemIdQueryOptions(passholderId,cardSystemId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Allow passholders to self check-in at an event using a check-in code (typically a QR code the passholder can scan). If you want to check-in a passholder based on an event id, use [POST /checkins](/reference/uitpas.json/paths/~1checkins/post) instead. 

If a user access token of a passholder is used, you can specify the path parameter `passholderId` as:
- the id of the passsholder of the access token (you can retrieve the id using `/passholders/me`)
- `me` as a short form for the passholder of the access token
- a passholder id of one of the passholder's family members

If a user access token of an admin, or a client access token is used, `me` cannot be used as a passholder id.

The caller of this method must have `PASSHOLDERS_SELF_CHECKIN` permission for the given passholder.
 * @summary Check-in passholder using a check-in code
 */
export type postPassholdersPassholderIdCheckinResponse201 = {
  data: PostPassholdersPassholderIdCheckin201
  status: 201
}

export type postPassholdersPassholderIdCheckinResponse400 = {
  data: Error
  status: 400
}

export type postPassholdersPassholderIdCheckinResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type postPassholdersPassholderIdCheckinResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type postPassholdersPassholderIdCheckinResponse429 = {
  data: Error
  status: 429
}

export type postPassholdersPassholderIdCheckinResponseSuccess = (postPassholdersPassholderIdCheckinResponse201) & {
  headers: Headers;
};
export type postPassholdersPassholderIdCheckinResponseError = (postPassholdersPassholderIdCheckinResponse400 | postPassholdersPassholderIdCheckinResponse401 | postPassholdersPassholderIdCheckinResponse403 | postPassholdersPassholderIdCheckinResponse429) & {
  headers: Headers;
};

export type postPassholdersPassholderIdCheckinResponse = (postPassholdersPassholderIdCheckinResponseSuccess | postPassholdersPassholderIdCheckinResponseError)

export const getPostPassholdersPassholderIdCheckinUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/checkins`
}

export const postPassholdersPassholderIdCheckin = async (passholderId: string,
    postPassholdersPassholderIdCheckinBody: PostPassholdersPassholderIdCheckinBody, options?: RequestInit): Promise<postPassholdersPassholderIdCheckinResponse> => {
  
  const res = await fetch(getPostPassholdersPassholderIdCheckinUrl(passholderId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postPassholdersPassholderIdCheckinBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postPassholdersPassholderIdCheckinResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postPassholdersPassholderIdCheckinResponse
}
  



export const getPostPassholdersPassholderIdCheckinMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholdersPassholderIdCheckin>>, TError,{passholderId: string;data: PostPassholdersPassholderIdCheckinBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postPassholdersPassholderIdCheckin>>, TError,{passholderId: string;data: PostPassholdersPassholderIdCheckinBody}, TContext> => {

const mutationKey = ['postPassholdersPassholderIdCheckin'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPassholdersPassholderIdCheckin>>, {passholderId: string;data: PostPassholdersPassholderIdCheckinBody}> = (props) => {
          const {passholderId,data} = props ?? {};

          return  postPassholdersPassholderIdCheckin(passholderId,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostPassholdersPassholderIdCheckinMutationResult = NonNullable<Awaited<ReturnType<typeof postPassholdersPassholderIdCheckin>>>
    export type PostPassholdersPassholderIdCheckinMutationBody = PostPassholdersPassholderIdCheckinBody
    export type PostPassholdersPassholderIdCheckinMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Check-in passholder using a check-in code
 */
export const usePostPassholdersPassholderIdCheckin = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholdersPassholderIdCheckin>>, TError,{passholderId: string;data: PostPassholdersPassholderIdCheckinBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPassholdersPassholderIdCheckin>>,
        TError,
        {passholderId: string;data: PostPassholdersPassholderIdCheckinBody},
        TContext
      > => {
      return useMutation(getPostPassholdersPassholderIdCheckinMutationOptions(options), queryClient);
    }
    /**
 * Retrieve the transaction history of the passholder.

If a user access token of a passholder is used, you can specify the path parameter `passholderId` as:
- the id of the passsholder of the access token (you can retrieve the id using `/passholders/me`)
- `me` as a short form for the passholder of the access token
- a passholder id of one of the passholder's family members

If a user access token of an admin, or a client access token is used, `me` cannot be used as a passholder id.

The caller of this method must have `PASSHOLDERS_SELF_CHECKIN` permission for the given passholder.
 * @summary Retrieve transaction history of a passholder
 */
export type getPassholdersPassholderIdTransactionsResponse200 = {
  data: TransactionsPaginatedCollection
  status: 200
}

export type getPassholdersPassholderIdTransactionsResponse400 = {
  data: Error
  status: 400
}

export type getPassholdersPassholderIdTransactionsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersPassholderIdTransactionsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersPassholderIdTransactionsResponseSuccess = (getPassholdersPassholderIdTransactionsResponse200) & {
  headers: Headers;
};
export type getPassholdersPassholderIdTransactionsResponseError = (getPassholdersPassholderIdTransactionsResponse400 | getPassholdersPassholderIdTransactionsResponse401 | getPassholdersPassholderIdTransactionsResponse403) & {
  headers: Headers;
};

export type getPassholdersPassholderIdTransactionsResponse = (getPassholdersPassholderIdTransactionsResponseSuccess | getPassholdersPassholderIdTransactionsResponseError)

export const getGetPassholdersPassholderIdTransactionsUrl = (passholderId: string,
    params?: GetPassholdersPassholderIdTransactionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/transactions?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/transactions`
}

export const getPassholdersPassholderIdTransactions = async (passholderId: string,
    params?: GetPassholdersPassholderIdTransactionsParams, options?: RequestInit): Promise<getPassholdersPassholderIdTransactionsResponse> => {
  
  const res = await fetch(getGetPassholdersPassholderIdTransactionsUrl(passholderId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersPassholderIdTransactionsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersPassholderIdTransactionsResponse
}
  




export const getGetPassholdersPassholderIdTransactionsQueryKey = (passholderId: string,
    params?: GetPassholdersPassholderIdTransactionsParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/transactions`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPassholdersPassholderIdTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(passholderId: string,
    params?: GetPassholdersPassholderIdTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersPassholderIdTransactionsQueryKey(passholderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>> = ({ signal }) => getPassholdersPassholderIdTransactions(passholderId,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(passholderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersPassholderIdTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>>
export type GetPassholdersPassholderIdTransactionsQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetPassholdersPassholderIdTransactions<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    params: undefined |  GetPassholdersPassholderIdTransactionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdTransactions<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    params?: GetPassholdersPassholderIdTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdTransactions<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    params?: GetPassholdersPassholderIdTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve transaction history of a passholder
 */

export function useGetPassholdersPassholderIdTransactions<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 passholderId: string,
    params?: GetPassholdersPassholderIdTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdTransactions>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersPassholderIdTransactionsQueryOptions(passholderId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve information related to a pass, searched by UiTPAS number.

If the response contains `messages`, they MUST be displayed to the end-user.

The caller of this request must have `PASSES_READ` permission.
 * @summary Retrieve pass by UiTPAS number
 */
export type getPassesUitpasNumberResponse200 = {
  data: Pass
  status: 200
}

export type getPassesUitpasNumberResponse400 = {
  data: Error
  status: 400
}

export type getPassesUitpasNumberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassesUitpasNumberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassesUitpasNumberResponse404 = {
  data: Error
  status: 404
}

export type getPassesUitpasNumberResponseSuccess = (getPassesUitpasNumberResponse200) & {
  headers: Headers;
};
export type getPassesUitpasNumberResponseError = (getPassesUitpasNumberResponse400 | getPassesUitpasNumberResponse401 | getPassesUitpasNumberResponse403 | getPassesUitpasNumberResponse404) & {
  headers: Headers;
};

export type getPassesUitpasNumberResponse = (getPassesUitpasNumberResponseSuccess | getPassesUitpasNumberResponseError)

export const getGetPassesUitpasNumberUrl = (uitpasNumber: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passes/${uitpasNumber}`
}

export const getPassesUitpasNumber = async (uitpasNumber: string, options?: RequestInit): Promise<getPassesUitpasNumberResponse> => {
  
  const res = await fetch(getGetPassesUitpasNumberUrl(uitpasNumber),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassesUitpasNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassesUitpasNumberResponse
}
  




export const getGetPassesUitpasNumberQueryKey = (uitpasNumber: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passes/${uitpasNumber}`
    ] as const;
    }

    
export const getGetPassesUitpasNumberQueryOptions = <TData = Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(uitpasNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassesUitpasNumberQueryKey(uitpasNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassesUitpasNumber>>> = ({ signal }) => getPassesUitpasNumber(uitpasNumber, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(uitpasNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassesUitpasNumberQueryResult = NonNullable<Awaited<ReturnType<typeof getPassesUitpasNumber>>>
export type GetPassesUitpasNumberQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetPassesUitpasNumber<TData = Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 uitpasNumber: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassesUitpasNumber>>,
          TError,
          Awaited<ReturnType<typeof getPassesUitpasNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassesUitpasNumber<TData = Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 uitpasNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassesUitpasNumber>>,
          TError,
          Awaited<ReturnType<typeof getPassesUitpasNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassesUitpasNumber<TData = Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 uitpasNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve pass by UiTPAS number
 */

export function useGetPassesUitpasNumber<TData = Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 uitpasNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassesUitpasNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassesUitpasNumberQueryOptions(uitpasNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve information related to a pass, searched by INSZ number.

If the response contains `messages`, they MUST be displayed to the end-user.

The caller of this request must have `PASSES_INSZNUMBERS_READ` permission.
 * @summary Retrieve pass by INSZ number
 */
export type getInszNumbersInszNumberResponse200 = {
  data: Pass
  status: 200
}

export type getInszNumbersInszNumberResponse400 = {
  data: Error
  status: 400
}

export type getInszNumbersInszNumberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getInszNumbersInszNumberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getInszNumbersInszNumberResponse404 = {
  data: Error
  status: 404
}

export type getInszNumbersInszNumberResponseSuccess = (getInszNumbersInszNumberResponse200) & {
  headers: Headers;
};
export type getInszNumbersInszNumberResponseError = (getInszNumbersInszNumberResponse400 | getInszNumbersInszNumberResponse401 | getInszNumbersInszNumberResponse403 | getInszNumbersInszNumberResponse404) & {
  headers: Headers;
};

export type getInszNumbersInszNumberResponse = (getInszNumbersInszNumberResponseSuccess | getInszNumbersInszNumberResponseError)

export const getGetInszNumbersInszNumberUrl = (inszNumber: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/insz-numbers/${inszNumber}`
}

export const getInszNumbersInszNumber = async (inszNumber: string, options?: RequestInit): Promise<getInszNumbersInszNumberResponse> => {
  
  const res = await fetch(getGetInszNumbersInszNumberUrl(inszNumber),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getInszNumbersInszNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getInszNumbersInszNumberResponse
}
  




export const getGetInszNumbersInszNumberQueryKey = (inszNumber: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/insz-numbers/${inszNumber}`
    ] as const;
    }

    
export const getGetInszNumbersInszNumberQueryOptions = <TData = Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInszNumbersInszNumberQueryKey(inszNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInszNumbersInszNumber>>> = ({ signal }) => getInszNumbersInszNumber(inszNumber, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(inszNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInszNumbersInszNumberQueryResult = NonNullable<Awaited<ReturnType<typeof getInszNumbersInszNumber>>>
export type GetInszNumbersInszNumberQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetInszNumbersInszNumber<TData = Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 inszNumber: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInszNumbersInszNumber>>,
          TError,
          Awaited<ReturnType<typeof getInszNumbersInszNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInszNumbersInszNumber<TData = Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInszNumbersInszNumber>>,
          TError,
          Awaited<ReturnType<typeof getInszNumbersInszNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInszNumbersInszNumber<TData = Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve pass by INSZ number
 */

export function useGetInszNumbersInszNumber<TData = Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInszNumbersInszNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInszNumbersInszNumberQueryOptions(inszNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve information related to a pass, searched by chip number.

If the response contains `messages`, they MUST be displayed to the end-user.

The caller of this request must have `PASSES_CHIPNUMBERS_READ` permission.
 * @summary Retrieve pass by chip number
 */
export type getChipNumbersChipNumberResponse200 = {
  data: Pass
  status: 200
}

export type getChipNumbersChipNumberResponse400 = {
  data: Error
  status: 400
}

export type getChipNumbersChipNumberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getChipNumbersChipNumberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getChipNumbersChipNumberResponse404 = {
  data: Error
  status: 404
}

export type getChipNumbersChipNumberResponseSuccess = (getChipNumbersChipNumberResponse200) & {
  headers: Headers;
};
export type getChipNumbersChipNumberResponseError = (getChipNumbersChipNumberResponse400 | getChipNumbersChipNumberResponse401 | getChipNumbersChipNumberResponse403 | getChipNumbersChipNumberResponse404) & {
  headers: Headers;
};

export type getChipNumbersChipNumberResponse = (getChipNumbersChipNumberResponseSuccess | getChipNumbersChipNumberResponseError)

export const getGetChipNumbersChipNumberUrl = (chipNumber: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/chip-numbers/${chipNumber}`
}

export const getChipNumbersChipNumber = async (chipNumber: string, options?: RequestInit): Promise<getChipNumbersChipNumberResponse> => {
  
  const res = await fetch(getGetChipNumbersChipNumberUrl(chipNumber),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getChipNumbersChipNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getChipNumbersChipNumberResponse
}
  




export const getGetChipNumbersChipNumberQueryKey = (chipNumber: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/chip-numbers/${chipNumber}`
    ] as const;
    }

    
export const getGetChipNumbersChipNumberQueryOptions = <TData = Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChipNumbersChipNumberQueryKey(chipNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChipNumbersChipNumber>>> = ({ signal }) => getChipNumbersChipNumber(chipNumber, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chipNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChipNumbersChipNumberQueryResult = NonNullable<Awaited<ReturnType<typeof getChipNumbersChipNumber>>>
export type GetChipNumbersChipNumberQueryError = Error | UnauthorizedResponse | ForbiddenResponse


export function useGetChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChipNumbersChipNumber>>,
          TError,
          Awaited<ReturnType<typeof getChipNumbersChipNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChipNumbersChipNumber>>,
          TError,
          Awaited<ReturnType<typeof getChipNumbersChipNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve pass by chip number
 */

export function useGetChipNumbersChipNumber<TData = Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse>(
 chipNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChipNumbersChipNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChipNumbersChipNumberQueryOptions(chipNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve the status of a passholder based on INSZ number.

This endpoint is rate limited.

 * @summary Retrieve the status of a passholder based on INSZ number
 */
export type passholdersStatusInszNumbersInsznumberResponse200 = {
  data: PassholdersStatusInszNumbersInsznumber200
  status: 200
}

export type passholdersStatusInszNumbersInsznumberResponse400 = {
  data: Error
  status: 400
}

export type passholdersStatusInszNumbersInsznumberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type passholdersStatusInszNumbersInsznumberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type passholdersStatusInszNumbersInsznumberResponse429 = {
  data: void
  status: 429
}

export type passholdersStatusInszNumbersInsznumberResponseSuccess = (passholdersStatusInszNumbersInsznumberResponse200) & {
  headers: Headers;
};
export type passholdersStatusInszNumbersInsznumberResponseError = (passholdersStatusInszNumbersInsznumberResponse400 | passholdersStatusInszNumbersInsznumberResponse401 | passholdersStatusInszNumbersInsznumberResponse403 | passholdersStatusInszNumbersInsznumberResponse429) & {
  headers: Headers;
};

export type passholdersStatusInszNumbersInsznumberResponse = (passholdersStatusInszNumbersInsznumberResponseSuccess | passholdersStatusInszNumbersInsznumberResponseError)

export const getPassholdersStatusInszNumbersInsznumberUrl = (inszNumber: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/status/insz-numbers/${inszNumber}`
}

export const passholdersStatusInszNumbersInsznumber = async (inszNumber: string, options?: RequestInit): Promise<passholdersStatusInszNumbersInsznumberResponse> => {
  
  const res = await fetch(getPassholdersStatusInszNumbersInsznumberUrl(inszNumber),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: passholdersStatusInszNumbersInsznumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as passholdersStatusInszNumbersInsznumberResponse
}
  




export const getPassholdersStatusInszNumbersInsznumberQueryKey = (inszNumber: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/status/insz-numbers/${inszNumber}`
    ] as const;
    }

    
export const getPassholdersStatusInszNumbersInsznumberQueryOptions = <TData = Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse | void>(inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPassholdersStatusInszNumbersInsznumberQueryKey(inszNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>> = ({ signal }) => passholdersStatusInszNumbersInsznumber(inszNumber, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(inszNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PassholdersStatusInszNumbersInsznumberQueryResult = NonNullable<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>>
export type PassholdersStatusInszNumbersInsznumberQueryError = Error | UnauthorizedResponse | ForbiddenResponse | void


export function usePassholdersStatusInszNumbersInsznumber<TData = Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse | void>(
 inszNumber: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>,
          TError,
          Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePassholdersStatusInszNumbersInsznumber<TData = Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse | void>(
 inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>,
          TError,
          Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePassholdersStatusInszNumbersInsznumber<TData = Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse | void>(
 inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve the status of a passholder based on INSZ number
 */

export function usePassholdersStatusInszNumbersInsznumber<TData = Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError = Error | UnauthorizedResponse | ForbiddenResponse | void>(
 inszNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof passholdersStatusInszNumbersInsznumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPassholdersStatusInszNumbersInsznumberQueryOptions(inszNumber,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




