/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DownloadLinkResponse,
  Error,
  EventCardSystem,
  EventSettings,
  ForbiddenResponse,
  GetEventsQrCheckincodesDownloadlinkParams,
  UnauthorizedResponse
} from '.././model';





/**
 * Update the `EventCardSystem` objects of the given event.

The `EventCardSystem` object specifies that the event is available in
this specific card system and optionally what manual distribution keys are enabled.

This update is used to toggle the `enabled` state for specific card systems or distribution keys.

To update the `enabled` state for card systems or distribution keys, you typically retrieve the possible `EventCardSystem` objects first using  `GET /events/{eventId}/card-systems`. You can then reuse the response from the `GET` request, 
altering the `enabled` state. Note that you can also omit the name properties. 
Only the required fields are used in this update request.

However, in case you know the card system(s) and distribution key(s) in advance, you might also make this `PUT` request without prior `GET` e.g. in case you need to disable all card systems for an event, you can simply put an empty array `[]` to indicate that (missing card systems in the array will be treated the same way as card systems with `enabled: "false"`).
Also note the implementation of this `PUT` endpoint is robust enough to allow updating card systems before the event is known in UiTPAS. (so even before the `GET` returns a valid HTTP 200 response).


<!-- theme: warning -->

> **This endpoint is only needed for exceptional cases.** In most cases card systems and distribution keys are set automatically on events, so you don't need to retrieve or change them.

The caller of this request must have `EVENTS_UPDATE` permission for the organizer of this event or the caller of this request must have "Aanbod bewerken" permission in the UiTdatabank for the given event.

 * @summary Update event card systems
 */
export type putEventsCardSystemsResponse204 = {
  data: void
  status: 204
}

export type putEventsCardSystemsResponse400 = {
  data: Error
  status: 400
}

export type putEventsCardSystemsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type putEventsCardSystemsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type putEventsCardSystemsResponse404 = {
  data: Error
  status: 404
}

export type putEventsCardSystemsResponseSuccess = (putEventsCardSystemsResponse204) & {
  headers: Headers;
};
export type putEventsCardSystemsResponseError = (putEventsCardSystemsResponse400 | putEventsCardSystemsResponse401 | putEventsCardSystemsResponse403 | putEventsCardSystemsResponse404) & {
  headers: Headers;
};

export type putEventsCardSystemsResponse = (putEventsCardSystemsResponseSuccess | putEventsCardSystemsResponseError)

export const getPutEventsCardSystemsUrl = (eventId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/events/${eventId}/card-systems`
}

export const putEventsCardSystems = async (eventId: string,
    eventCardSystem: EventCardSystem[], options?: RequestInit): Promise<putEventsCardSystemsResponse> => {
  
  const res = await fetch(getPutEventsCardSystemsUrl(eventId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      eventCardSystem,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putEventsCardSystemsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putEventsCardSystemsResponse
}
  



export const getPutEventsCardSystemsMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEventsCardSystems>>, TError,{eventId: string;data: EventCardSystem[]}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putEventsCardSystems>>, TError,{eventId: string;data: EventCardSystem[]}, TContext> => {

const mutationKey = ['putEventsCardSystems'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putEventsCardSystems>>, {eventId: string;data: EventCardSystem[]}> = (props) => {
          const {eventId,data} = props ?? {};

          return  putEventsCardSystems(eventId,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutEventsCardSystemsMutationResult = NonNullable<Awaited<ReturnType<typeof putEventsCardSystems>>>
    export type PutEventsCardSystemsMutationBody = EventCardSystem[]
    export type PutEventsCardSystemsMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Update event card systems
 */
export const usePutEventsCardSystems = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEventsCardSystems>>, TError,{eventId: string;data: EventCardSystem[]}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putEventsCardSystems>>,
        TError,
        {eventId: string;data: EventCardSystem[]},
        TContext
      > => {
      return useMutation(getPutEventsCardSystemsMutationOptions(options), queryClient);
    }
    /**
 * Get all (enabled and disabled) `EventCardSystem` objects of the given event.

The `EventCardSystem` object specifies that the event is available in
this specific card system and optionally what manual distribution keys are enabled.

Every `EventCardSystem` or `ManualDistributionKey` has an `enabled` property that can be altered using `PUT /events/{eventId}/card-systems`.
 
<!-- theme: warning -->

> **This endpoint is only needed for exceptional cases.** In most cases card systems and distribution keys are set automatically on events, so you don't need to retrieve or change them.

The caller of this request must have `EVENTS_READ` permission for the organizer of this event.

 * @summary Get event card systems
 */
export type getEventsCardSystemsResponse200 = {
  data: EventCardSystem[]
  status: 200
}

export type getEventsCardSystemsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getEventsCardSystemsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getEventsCardSystemsResponse404 = {
  data: Error
  status: 404
}

export type getEventsCardSystemsResponseSuccess = (getEventsCardSystemsResponse200) & {
  headers: Headers;
};
export type getEventsCardSystemsResponseError = (getEventsCardSystemsResponse401 | getEventsCardSystemsResponse403 | getEventsCardSystemsResponse404) & {
  headers: Headers;
};

export type getEventsCardSystemsResponse = (getEventsCardSystemsResponseSuccess | getEventsCardSystemsResponseError)

export const getGetEventsCardSystemsUrl = (eventId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/events/${eventId}/card-systems`
}

export const getEventsCardSystems = async (eventId: string, options?: RequestInit): Promise<getEventsCardSystemsResponse> => {
  
  const res = await fetch(getGetEventsCardSystemsUrl(eventId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEventsCardSystemsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEventsCardSystemsResponse
}
  




export const getGetEventsCardSystemsQueryKey = (eventId: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/events/${eventId}/card-systems`
    ] as const;
    }

    
export const getGetEventsCardSystemsQueryOptions = <TData = Awaited<ReturnType<typeof getEventsCardSystems>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsCardSystems>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventsCardSystemsQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventsCardSystems>>> = ({ signal }) => getEventsCardSystems(eventId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventsCardSystems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventsCardSystemsQueryResult = NonNullable<Awaited<ReturnType<typeof getEventsCardSystems>>>
export type GetEventsCardSystemsQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetEventsCardSystems<TData = Awaited<ReturnType<typeof getEventsCardSystems>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsCardSystems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsCardSystems>>,
          TError,
          Awaited<ReturnType<typeof getEventsCardSystems>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsCardSystems<TData = Awaited<ReturnType<typeof getEventsCardSystems>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsCardSystems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsCardSystems>>,
          TError,
          Awaited<ReturnType<typeof getEventsCardSystems>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsCardSystems<TData = Awaited<ReturnType<typeof getEventsCardSystems>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsCardSystems>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get event card systems
 */

export function useGetEventsCardSystems<TData = Awaited<ReturnType<typeof getEventsCardSystems>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsCardSystems>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventsCardSystemsQueryOptions(eventId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update the event settings of the given event.

Make sure to perform a `GET events/{eventId}/settings` first, apply your changes and PUT the complete object using this request.

The caller of this request must have `EVENT_SETTINGS_UPDATE` permission for the organizer of this event.

 * @summary Update event settings
 */
export type putEventsSettingsResponse204 = {
  data: void
  status: 204
}

export type putEventsSettingsResponse400 = {
  data: Error
  status: 400
}

export type putEventsSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type putEventsSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type putEventsSettingsResponse404 = {
  data: Error
  status: 404
}

export type putEventsSettingsResponseSuccess = (putEventsSettingsResponse204) & {
  headers: Headers;
};
export type putEventsSettingsResponseError = (putEventsSettingsResponse400 | putEventsSettingsResponse401 | putEventsSettingsResponse403 | putEventsSettingsResponse404) & {
  headers: Headers;
};

export type putEventsSettingsResponse = (putEventsSettingsResponseSuccess | putEventsSettingsResponseError)

export const getPutEventsSettingsUrl = (eventId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/events/${eventId}/settings`
}

export const putEventsSettings = async (eventId: string,
    eventSettings: EventSettings, options?: RequestInit): Promise<putEventsSettingsResponse> => {
  
  const res = await fetch(getPutEventsSettingsUrl(eventId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      eventSettings,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putEventsSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putEventsSettingsResponse
}
  



export const getPutEventsSettingsMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEventsSettings>>, TError,{eventId: string;data: EventSettings}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putEventsSettings>>, TError,{eventId: string;data: EventSettings}, TContext> => {

const mutationKey = ['putEventsSettings'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putEventsSettings>>, {eventId: string;data: EventSettings}> = (props) => {
          const {eventId,data} = props ?? {};

          return  putEventsSettings(eventId,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutEventsSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof putEventsSettings>>>
    export type PutEventsSettingsMutationBody = EventSettings
    export type PutEventsSettingsMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Update event settings
 */
export const usePutEventsSettings = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEventsSettings>>, TError,{eventId: string;data: EventSettings}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putEventsSettings>>,
        TError,
        {eventId: string;data: EventSettings},
        TContext
      > => {
      return useMutation(getPutEventsSettingsMutationOptions(options), queryClient);
    }
    /**
 * Get event settings of the given event.

The caller of this request must have `EVENT_SETTINGS_READ` permission for the organizer of this event.

 * @summary Get event settings
 */
export type getEventsSettingsResponse200 = {
  data: EventSettings
  status: 200
}

export type getEventsSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getEventsSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getEventsSettingsResponse404 = {
  data: Error
  status: 404
}

export type getEventsSettingsResponseSuccess = (getEventsSettingsResponse200) & {
  headers: Headers;
};
export type getEventsSettingsResponseError = (getEventsSettingsResponse401 | getEventsSettingsResponse403 | getEventsSettingsResponse404) & {
  headers: Headers;
};

export type getEventsSettingsResponse = (getEventsSettingsResponseSuccess | getEventsSettingsResponseError)

export const getGetEventsSettingsUrl = (eventId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/events/${eventId}/settings`
}

export const getEventsSettings = async (eventId: string, options?: RequestInit): Promise<getEventsSettingsResponse> => {
  
  const res = await fetch(getGetEventsSettingsUrl(eventId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEventsSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEventsSettingsResponse
}
  




export const getGetEventsSettingsQueryKey = (eventId: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/events/${eventId}/settings`
    ] as const;
    }

    
export const getGetEventsSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getEventsSettings>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsSettings>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventsSettingsQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventsSettings>>> = ({ signal }) => getEventsSettings(eventId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventsSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventsSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getEventsSettings>>>
export type GetEventsSettingsQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetEventsSettings<TData = Awaited<ReturnType<typeof getEventsSettings>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsSettings>>,
          TError,
          Awaited<ReturnType<typeof getEventsSettings>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsSettings<TData = Awaited<ReturnType<typeof getEventsSettings>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsSettings>>,
          TError,
          Awaited<ReturnType<typeof getEventsSettings>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsSettings<TData = Awaited<ReturnType<typeof getEventsSettings>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsSettings>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get event settings
 */

export function useGetEventsSettings<TData = Awaited<ReturnType<typeof getEventsSettings>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsSettings>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventsSettingsQueryOptions(eventId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get a temporary download link to the QR checkin code of the given event.

This endpoint allows you to obtain a short-lived, hassle-free download link for your QR checkin code. After generation, this link remains active for a limited time, enabling direct QR downloads without the need for additional authentication. This is in particular convenient for applications that need to offer this link to users to start the download.
 
The caller of this request must have `EVENTS_QR_CHECKINCODE` permission for the organizer of this event.

 * @summary Get event QR checkin code as download link
 */
export type getEventsQrCheckincodesDownloadlinkResponse200 = {
  data: DownloadLinkResponse
  status: 200
}

export type getEventsQrCheckincodesDownloadlinkResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getEventsQrCheckincodesDownloadlinkResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getEventsQrCheckincodesDownloadlinkResponse404 = {
  data: Error
  status: 404
}

export type getEventsQrCheckincodesDownloadlinkResponseSuccess = (getEventsQrCheckincodesDownloadlinkResponse200) & {
  headers: Headers;
};
export type getEventsQrCheckincodesDownloadlinkResponseError = (getEventsQrCheckincodesDownloadlinkResponse401 | getEventsQrCheckincodesDownloadlinkResponse403 | getEventsQrCheckincodesDownloadlinkResponse404) & {
  headers: Headers;
};

export type getEventsQrCheckincodesDownloadlinkResponse = (getEventsQrCheckincodesDownloadlinkResponseSuccess | getEventsQrCheckincodesDownloadlinkResponseError)

export const getGetEventsQrCheckincodesDownloadlinkUrl = (eventId: string,
    params?: GetEventsQrCheckincodesDownloadlinkParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `NEXT_PUBLIC_API_PATH/events/${eventId}/qr-checkincodes/download-link?${stringifiedParams}` : `NEXT_PUBLIC_API_PATH/events/${eventId}/qr-checkincodes/download-link`
}

export const getEventsQrCheckincodesDownloadlink = async (eventId: string,
    params?: GetEventsQrCheckincodesDownloadlinkParams, options?: RequestInit): Promise<getEventsQrCheckincodesDownloadlinkResponse> => {
  
  const res = await fetch(getGetEventsQrCheckincodesDownloadlinkUrl(eventId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEventsQrCheckincodesDownloadlinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEventsQrCheckincodesDownloadlinkResponse
}
  




export const getGetEventsQrCheckincodesDownloadlinkQueryKey = (eventId: string,
    params?: GetEventsQrCheckincodesDownloadlinkParams,) => {
    return [
    `NEXT_PUBLIC_API_PATH/events/${eventId}/qr-checkincodes/download-link`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetEventsQrCheckincodesDownloadlinkQueryOptions = <TData = Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(eventId: string,
    params?: GetEventsQrCheckincodesDownloadlinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventsQrCheckincodesDownloadlinkQueryKey(eventId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>> = ({ signal }) => getEventsQrCheckincodesDownloadlink(eventId,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventsQrCheckincodesDownloadlinkQueryResult = NonNullable<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>>
export type GetEventsQrCheckincodesDownloadlinkQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetEventsQrCheckincodesDownloadlink<TData = Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string,
    params: undefined |  GetEventsQrCheckincodesDownloadlinkParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>,
          TError,
          Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsQrCheckincodesDownloadlink<TData = Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string,
    params?: GetEventsQrCheckincodesDownloadlinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>,
          TError,
          Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsQrCheckincodesDownloadlink<TData = Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string,
    params?: GetEventsQrCheckincodesDownloadlinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get event QR checkin code as download link
 */

export function useGetEventsQrCheckincodesDownloadlink<TData = Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 eventId: string,
    params?: GetEventsQrCheckincodesDownloadlinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsQrCheckincodesDownloadlink>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventsQrCheckincodesDownloadlinkQueryOptions(eventId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




