/**
 * Generated by orval v8.4.2 ðŸº
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Error,
  ForbiddenResponse,
  GetUitidPassholderRegistrationToken200,
  GetUitidPassholderStatus200,
  Passholder,
  PassholderSelfRegistration,
  UnauthorizedResponse
} from '.././model';





/**
 * This is step 1 of the process to register an UiTPAS passholder in UiTiD using their UiTPAS number and date of birth. It is used to retrieve an UiTiD registration token for the passholder. If the passholder already has a token via an email they received to register in UiTiD, this step can be skipped.

This endpoint uses [HTTP Basic Authentication](https://datatracker.ietf.org/doc/html/rfc7617) using:
* Username: uitpasNumber 
* Password: dateOfBirth in the form yyyy-mm-dd

In summary, this header should look like: 

```
Authorization: Basic base64(uitpasNumber:dateOfBirth)
```

The response will contain a `token` property that can be used in step 2 of the process, [retrieving the UiTiD registration status](/reference/uitpas.json/paths/~1passholders~1me~1uitid~1status/get).

This caller of this method is identified with [client identification](https://docs.publiq.be/docs/authentication/ZG9jOjExODE5NDY5-client-identification) and does not require any permissions, but please note this endpoint is rate-limited on IP address to prevent abuse.
 * @summary Retrieve UiTiD registration token
 */
export type getUitidPassholderRegistrationTokenResponse200 = {
  data: GetUitidPassholderRegistrationToken200
  status: 200
}

export type getUitidPassholderRegistrationTokenResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getUitidPassholderRegistrationTokenResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getUitidPassholderRegistrationTokenResponse429 = {
  data: Error
  status: 429
}

export type getUitidPassholderRegistrationTokenResponseSuccess = (getUitidPassholderRegistrationTokenResponse200) & {
  headers: Headers;
};
export type getUitidPassholderRegistrationTokenResponseError = (getUitidPassholderRegistrationTokenResponse401 | getUitidPassholderRegistrationTokenResponse403 | getUitidPassholderRegistrationTokenResponse429) & {
  headers: Headers;
};

export type getUitidPassholderRegistrationTokenResponse = (getUitidPassholderRegistrationTokenResponseSuccess | getUitidPassholderRegistrationTokenResponseError)

export const getGetUitidPassholderRegistrationTokenUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/me/uitid/registration-token`
}

export const getUitidPassholderRegistrationToken = async ( options?: RequestInit): Promise<getUitidPassholderRegistrationTokenResponse> => {
  
  const res = await fetch(getGetUitidPassholderRegistrationTokenUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUitidPassholderRegistrationTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUitidPassholderRegistrationTokenResponse
}
  




export const getGetUitidPassholderRegistrationTokenQueryKey = () => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/me/uitid/registration-token`
    ] as const;
    }

    
export const getGetUitidPassholderRegistrationTokenQueryOptions = <TData = Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUitidPassholderRegistrationTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>> = ({ signal }) => getUitidPassholderRegistrationToken({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUitidPassholderRegistrationTokenQueryResult = NonNullable<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>>
export type GetUitidPassholderRegistrationTokenQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetUitidPassholderRegistrationToken<TData = Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>,
          TError,
          Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUitidPassholderRegistrationToken<TData = Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>,
          TError,
          Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUitidPassholderRegistrationToken<TData = Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve UiTiD registration token
 */

export function useGetUitidPassholderRegistrationToken<TData = Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUitidPassholderRegistrationTokenQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieves the UiTiD registration status of a passholder. This is step 2 in the process of registering an UiTPAS passholder in UiTiD.

This endpoint requires a registation token in the `x-registration-token` header. A client can obtain such a token using [`GET /passholders/me/uitid/registration-token`](/reference/uitpas.json/paths/~1passholders~1me~1uitid~1registration-token/get). Alternatively, a token may already be available to the client because the user may have received an email link including it.

Based on the state value, the client can proceed in 2 ways:

- If state is `UNREGISTERED`

The passholder can proceed to step 3, [retrieving the UiTiD email address status](/reference/uitpas.json/paths/~1uitid~1emails~1{email}/get).

The response can include the linked `email` address of the passholder if one is known. This can be used in the next step of the registration process ([`GET /uitid/emails/{email}`](/reference/uitpas.json/paths/~1uitid~1emails~1{email}/get)). If no email address is included, the client should prompt the user to enter their email address first before proceeding to step 3.

- If state is `REGISTERED` 

The passholder is already `REGISTERED` so the user must continue by authenticating instead. The `email` address field contains the email address of the linked UiTiD account that should be used to authenticate.


This caller of this method, identified with [client identification](https://docs.publiq.be/docs/authentication/ZG9jOjExODE5NDY5-client-identification) does not require any permissions.
 * @summary Retrieve UiTiD registration status
 */
export type getUitidPassholderStatusResponse200 = {
  data: GetUitidPassholderStatus200
  status: 200
}

export type getUitidPassholderStatusResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getUitidPassholderStatusResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getUitidPassholderStatusResponse429 = {
  data: Error
  status: 429
}

export type getUitidPassholderStatusResponseSuccess = (getUitidPassholderStatusResponse200) & {
  headers: Headers;
};
export type getUitidPassholderStatusResponseError = (getUitidPassholderStatusResponse401 | getUitidPassholderStatusResponse403 | getUitidPassholderStatusResponse429) & {
  headers: Headers;
};

export type getUitidPassholderStatusResponse = (getUitidPassholderStatusResponseSuccess | getUitidPassholderStatusResponseError)

export const getGetUitidPassholderStatusUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/me/uitid/status`
}

export const getUitidPassholderStatus = async ( options?: RequestInit): Promise<getUitidPassholderStatusResponse> => {
  
  const res = await fetch(getGetUitidPassholderStatusUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUitidPassholderStatusResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUitidPassholderStatusResponse
}
  




export const getGetUitidPassholderStatusQueryKey = () => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/me/uitid/status`
    ] as const;
    }

    
export const getGetUitidPassholderStatusQueryOptions = <TData = Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUitidPassholderStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUitidPassholderStatus>>> = ({ signal }) => getUitidPassholderStatus({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUitidPassholderStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getUitidPassholderStatus>>>
export type GetUitidPassholderStatusQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetUitidPassholderStatus<TData = Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUitidPassholderStatus>>,
          TError,
          Awaited<ReturnType<typeof getUitidPassholderStatus>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUitidPassholderStatus<TData = Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUitidPassholderStatus>>,
          TError,
          Awaited<ReturnType<typeof getUitidPassholderStatus>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUitidPassholderStatus<TData = Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve UiTiD registration status
 */

export function useGetUitidPassholderStatus<TData = Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUitidPassholderStatus>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUitidPassholderStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Registers the UiTiD for this passholder. This is step 4, and the final step, in the process of registering an UiTPAS passholder in UiTiD.

This request requires an `Authorization` header with the [user access token](https://docs.publiq.be/docs/authentication/ZG9jOjExODE5NTM5-user-access-token) of an authenticated UiTiD *and* it requires a `x-registration-token` header containing a valid registration token of the passholder.

A user access token of a client with `PASSHOLDERS_REGISTER_UITID` permission is mandatory.
 * @summary Register UiTiD for passholder
 */
export type registerUitidPassholderResponse201 = {
  data: void
  status: 201
}

export type registerUitidPassholderResponse400 = {
  data: Error
  status: 400
}

export type registerUitidPassholderResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type registerUitidPassholderResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type registerUitidPassholderResponseSuccess = (registerUitidPassholderResponse201) & {
  headers: Headers;
};
export type registerUitidPassholderResponseError = (registerUitidPassholderResponse400 | registerUitidPassholderResponse401 | registerUitidPassholderResponse403) & {
  headers: Headers;
};

export type registerUitidPassholderResponse = (registerUitidPassholderResponseSuccess | registerUitidPassholderResponseError)

export const getRegisterUitidPassholderUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/me/uitid`
}

export const registerUitidPassholder = async ( options?: RequestInit): Promise<registerUitidPassholderResponse> => {
  
  const res = await fetch(getRegisterUitidPassholderUrl(),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: registerUitidPassholderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as registerUitidPassholderResponse
}
  



export const getRegisterUitidPassholderMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUitidPassholder>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof registerUitidPassholder>>, TError,void, TContext> => {

const mutationKey = ['registerUitidPassholder'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUitidPassholder>>, void> = () => {
          

          return  registerUitidPassholder(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUitidPassholderMutationResult = NonNullable<Awaited<ReturnType<typeof registerUitidPassholder>>>
    
    export type RegisterUitidPassholderMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Register UiTiD for passholder
 */
export const useRegisterUitidPassholder = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUitidPassholder>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerUitidPassholder>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getRegisterUitidPassholderMutationOptions(options), queryClient);
    }
    /**
 * Allows users to retrieve their passholder using a user access token.

A user access token of a client with `PASSHOLDERS_SELF_READ` permission is mandatory. The passholder is retrieved by `inszNumber` if the access token contains the custom claim `https://publiq.be/rrn` (i.e. user has logged in using connection ACM), or by linked UiTiD user (`sub` or `https://publiq.be/uitidv1id` claim of the user access token).
 * @summary Retrieve passholder for the current user
 */
export type getPassholdersMeResponse200 = {
  data: Passholder
  status: 200
}

export type getPassholdersMeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersMeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersMeResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersMeResponseSuccess = (getPassholdersMeResponse200) & {
  headers: Headers;
};
export type getPassholdersMeResponseError = (getPassholdersMeResponse401 | getPassholdersMeResponse403 | getPassholdersMeResponse404) & {
  headers: Headers;
};

export type getPassholdersMeResponse = (getPassholdersMeResponseSuccess | getPassholdersMeResponseError)

export const getGetPassholdersMeUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/me`
}

export const getPassholdersMe = async ( options?: RequestInit): Promise<getPassholdersMeResponse> => {
  
  const res = await fetch(getGetPassholdersMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersMeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersMeResponse
}
  




export const getGetPassholdersMeQueryKey = () => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/me`
    ] as const;
    }

    
export const getGetPassholdersMeQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersMe>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMe>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersMe>>> = ({ signal }) => getPassholdersMe({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersMeQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersMe>>>
export type GetPassholdersMeQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetPassholdersMe<TData = Awaited<ReturnType<typeof getPassholdersMe>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersMe>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersMe<TData = Awaited<ReturnType<typeof getPassholdersMe>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersMe>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersMe<TData = Awaited<ReturnType<typeof getPassholdersMe>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve passholder for the current user
 */

export function useGetPassholdersMe<TData = Awaited<ReturnType<typeof getPassholdersMe>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * <!-- theme: warning -->

> WARNING
>
> Experimental API. Breaking changes might be introduced in future updates.

Allows users to self-register a passholder using a user access token.

A user access token of a client with `PASSHOLDERS_SELF_REGISTRATION` permission for the `registrationOrganizer` is mandatory. Furthermore, the user access token must contain the custom claim `https://publiq.be/rrn` (i.e. user has to login using connection ACM).

Please note a user can only self-register one passholder. Use `GET /passholders/me` to check if a passholder already exists for this user.
 * @summary Register passholder for the current user
 */
export type postPassholdersMeResponse200 = {
  data: Passholder
  status: 200
}

export type postPassholdersMeResponse400 = {
  data: Error
  status: 400
}

export type postPassholdersMeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type postPassholdersMeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type postPassholdersMeResponseSuccess = (postPassholdersMeResponse200) & {
  headers: Headers;
};
export type postPassholdersMeResponseError = (postPassholdersMeResponse400 | postPassholdersMeResponse401 | postPassholdersMeResponse403) & {
  headers: Headers;
};

export type postPassholdersMeResponse = (postPassholdersMeResponseSuccess | postPassholdersMeResponseError)

export const getPostPassholdersMeUrl = () => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/me`
}

export const postPassholdersMe = async (passholderSelfRegistration: PassholderSelfRegistration, options?: RequestInit): Promise<postPassholdersMeResponse> => {
  
  const res = await fetch(getPostPassholdersMeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      passholderSelfRegistration,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postPassholdersMeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postPassholdersMeResponse
}
  



export const getPostPassholdersMeMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholdersMe>>, TError,{data: PassholderSelfRegistration}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postPassholdersMe>>, TError,{data: PassholderSelfRegistration}, TContext> => {

const mutationKey = ['postPassholdersMe'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPassholdersMe>>, {data: PassholderSelfRegistration}> = (props) => {
          const {data} = props ?? {};

          return  postPassholdersMe(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostPassholdersMeMutationResult = NonNullable<Awaited<ReturnType<typeof postPassholdersMe>>>
    export type PostPassholdersMeMutationBody = PassholderSelfRegistration
    export type PostPassholdersMeMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Register passholder for the current user
 */
export const usePostPassholdersMe = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholdersMe>>, TError,{data: PassholderSelfRegistration}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPassholdersMe>>,
        TError,
        {data: PassholderSelfRegistration},
        TContext
      > => {
      return useMutation(getPostPassholdersMeMutationOptions(options), queryClient);
    }
    