/**
 * Generated by orval v8.5.0 üç∫
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Error,
  ForbiddenResponse,
  Organizer,
  UnauthorizedResponse
} from '.././model';





/**
 * Retrieve the passholder's school.

The caller of this request must have `PASSHOLDERS_SEARCH` permission.

<!-- theme: warning -->

> Passholder schools are used to manage passholders in a very specific case. If you are not explicitly working with UiTPAS schools, you will probably **NOT** need this API. 

Using [GET](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/get), [PUT](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/put) and [DELETE](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/delete) on this endpoint, the school of a passholder can be retrieved, updated and deleted. All schools are organizers.
 * @summary Get passholder school
 */
export type getPassholdersSchoolResponse200 = {
  data: Organizer
  status: 200
}

export type getPassholdersSchoolResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersSchoolResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersSchoolResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersSchoolResponseSuccess = (getPassholdersSchoolResponse200) & {
  headers: Headers;
};
export type getPassholdersSchoolResponseError = (getPassholdersSchoolResponse401 | getPassholdersSchoolResponse403 | getPassholdersSchoolResponse404) & {
  headers: Headers;
};

export type getPassholdersSchoolResponse = (getPassholdersSchoolResponseSuccess | getPassholdersSchoolResponseError)

export const getGetPassholdersSchoolUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/school`
}

export const getPassholdersSchool = async (passholderId: string, options?: RequestInit): Promise<getPassholdersSchoolResponse> => {
  
  const res = await fetch(getGetPassholdersSchoolUrl(passholderId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersSchoolResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersSchoolResponse
}
  




export const getGetPassholdersSchoolQueryKey = (passholderId: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/school`
    ] as const;
    }

    
export const getGetPassholdersSchoolQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersSchool>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersSchool>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersSchoolQueryKey(passholderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersSchool>>> = ({ signal }) => getPassholdersSchool(passholderId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(passholderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersSchool>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersSchoolQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersSchool>>>
export type GetPassholdersSchoolQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetPassholdersSchool<TData = Awaited<ReturnType<typeof getPassholdersSchool>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersSchool>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersSchool>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersSchool>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersSchool<TData = Awaited<ReturnType<typeof getPassholdersSchool>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersSchool>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersSchool>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersSchool>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersSchool<TData = Awaited<ReturnType<typeof getPassholdersSchool>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersSchool>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get passholder school
 */

export function useGetPassholdersSchool<TData = Awaited<ReturnType<typeof getPassholdersSchool>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersSchool>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersSchoolQueryOptions(passholderId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update the passholder's school relation.

The caller of this request must have `PASSHOLDERS_UPDATE` permission.

<!-- theme: warning -->

> Passholder schools are used to manage passholders in a very specific case. If you are not explicitly working with UiTPAS schools, you will probably **NOT** need this API. 

Using [GET](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/get), [PUT](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/put) and [DELETE](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/delete) on this endpoint, the school of a passholder can be retrieved, updated and deleted. All schools are organizers.
 * @summary Update passholder school
 */
export type putPassholdersSchoolResponse204 = {
  data: void
  status: 204
}

export type putPassholdersSchoolResponse400 = {
  data: Error
  status: 400
}

export type putPassholdersSchoolResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type putPassholdersSchoolResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type putPassholdersSchoolResponse404 = {
  data: Error
  status: 404
}

export type putPassholdersSchoolResponseSuccess = (putPassholdersSchoolResponse204) & {
  headers: Headers;
};
export type putPassholdersSchoolResponseError = (putPassholdersSchoolResponse400 | putPassholdersSchoolResponse401 | putPassholdersSchoolResponse403 | putPassholdersSchoolResponse404) & {
  headers: Headers;
};

export type putPassholdersSchoolResponse = (putPassholdersSchoolResponseSuccess | putPassholdersSchoolResponseError)

export const getPutPassholdersSchoolUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/school`
}

export const putPassholdersSchool = async (passholderId: string,
    organizer: Organizer, options?: RequestInit): Promise<putPassholdersSchoolResponse> => {
  
  const res = await fetch(getPutPassholdersSchoolUrl(passholderId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      organizer,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putPassholdersSchoolResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putPassholdersSchoolResponse
}
  



export const getPutPassholdersSchoolMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPassholdersSchool>>, TError,{passholderId: string;data: Organizer}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putPassholdersSchool>>, TError,{passholderId: string;data: Organizer}, TContext> => {

const mutationKey = ['putPassholdersSchool'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPassholdersSchool>>, {passholderId: string;data: Organizer}> = (props) => {
          const {passholderId,data} = props ?? {};

          return  putPassholdersSchool(passholderId,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutPassholdersSchoolMutationResult = NonNullable<Awaited<ReturnType<typeof putPassholdersSchool>>>
    export type PutPassholdersSchoolMutationBody = Organizer
    export type PutPassholdersSchoolMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Update passholder school
 */
export const usePutPassholdersSchool = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPassholdersSchool>>, TError,{passholderId: string;data: Organizer}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPassholdersSchool>>,
        TError,
        {passholderId: string;data: Organizer},
        TContext
      > => {
      return useMutation(getPutPassholdersSchoolMutationOptions(options), queryClient);
    }
    /**
 * Delete the passholder's school relation.

The user or client performing this request must have `PASSHOLDERS_UPDATE` permission.

<!-- theme: warning -->

> Passholder schools are used to manage passholders in a very specific case. If you are not explicitly working with UiTPAS schools, you will probably **NOT** need this API. 

Using [GET](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/get), [PUT](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/put) and [DELETE](/reference/uitpas.json/paths/~1passholders~1{passholderId}~1school/delete) on this endpoint, the school of a passholder can be retrieved, updated and deleted. All schools are organizers.
 * @summary Delete passholder school
 */
export type deletePassholdersSchoolResponse204 = {
  data: void
  status: 204
}

export type deletePassholdersSchoolResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deletePassholdersSchoolResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deletePassholdersSchoolResponse404 = {
  data: Error
  status: 404
}

export type deletePassholdersSchoolResponseSuccess = (deletePassholdersSchoolResponse204) & {
  headers: Headers;
};
export type deletePassholdersSchoolResponseError = (deletePassholdersSchoolResponse401 | deletePassholdersSchoolResponse403 | deletePassholdersSchoolResponse404) & {
  headers: Headers;
};

export type deletePassholdersSchoolResponse = (deletePassholdersSchoolResponseSuccess | deletePassholdersSchoolResponseError)

export const getDeletePassholdersSchoolUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/school`
}

export const deletePassholdersSchool = async (passholderId: string, options?: RequestInit): Promise<deletePassholdersSchoolResponse> => {
  
  const res = await fetch(getDeletePassholdersSchoolUrl(passholderId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deletePassholdersSchoolResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deletePassholdersSchoolResponse
}
  



export const getDeletePassholdersSchoolMutationOptions = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersSchool>>, TError,{passholderId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersSchool>>, TError,{passholderId: string}, TContext> => {

const mutationKey = ['deletePassholdersSchool'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePassholdersSchool>>, {passholderId: string}> = (props) => {
          const {passholderId} = props ?? {};

          return  deletePassholdersSchool(passholderId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePassholdersSchoolMutationResult = NonNullable<Awaited<ReturnType<typeof deletePassholdersSchool>>>
    
    export type DeletePassholdersSchoolMutationError = UnauthorizedResponse | ForbiddenResponse | Error

    /**
 * @summary Delete passholder school
 */
export const useDeletePassholdersSchool = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersSchool>>, TError,{passholderId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePassholdersSchool>>,
        TError,
        {passholderId: string},
        TContext
      > => {
      return useMutation(getDeletePassholdersSchoolMutationOptions(options), queryClient);
    }
    