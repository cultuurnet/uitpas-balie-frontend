/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Error,
  FamilyMember,
  ForbiddenResponse,
  GetPassholdersPassholderIdFamilies200Item,
  UnauthorizedResponse
} from '.././model';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * Retrieve family members of a given passholder.

The list of family members is specific to this passholder, the family relation is not mutual, 
the total number of family members and the number of adults in a family is limited. 

The passholder identified by `{passholderId}` is always part of this list and its boolean property `mainFamilyMember` will be `true`.

The caller of this method must have `PASSHOLDERS_FAMILY_MEMBERS` permission for the given passholder.
 * @summary Retrieve family members of the current passholder
 */
export type getPassholdersPassholderIdFamilyMembersResponse200 = {
  data: FamilyMember[]
  status: 200
}

export type getPassholdersPassholderIdFamilyMembersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersPassholderIdFamilyMembersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersPassholderIdFamilyMembersResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersPassholderIdFamilyMembersResponseSuccess = (getPassholdersPassholderIdFamilyMembersResponse200) & {
  headers: Headers;
};
export type getPassholdersPassholderIdFamilyMembersResponseError = (getPassholdersPassholderIdFamilyMembersResponse401 | getPassholdersPassholderIdFamilyMembersResponse403 | getPassholdersPassholderIdFamilyMembersResponse404) & {
  headers: Headers;
};

export type getPassholdersPassholderIdFamilyMembersResponse = (getPassholdersPassholderIdFamilyMembersResponseSuccess | getPassholdersPassholderIdFamilyMembersResponseError)

export const getGetPassholdersPassholderIdFamilyMembersUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/family-members`
}

export const getPassholdersPassholderIdFamilyMembers = async (passholderId: string, options?: RequestInit): Promise<getPassholdersPassholderIdFamilyMembersResponse> => {
  
  const res = await fetch(getGetPassholdersPassholderIdFamilyMembersUrl(passholderId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersPassholderIdFamilyMembersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersPassholderIdFamilyMembersResponse
}
  




export const getGetPassholdersPassholderIdFamilyMembersQueryKey = (passholderId: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/family-members`
    ] as const;
    }

    
export const getGetPassholdersPassholderIdFamilyMembersQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersPassholderIdFamilyMembersQueryKey(passholderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>> = ({ signal }) => getPassholdersPassholderIdFamilyMembers(passholderId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(passholderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersPassholderIdFamilyMembersQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>>
export type GetPassholdersPassholderIdFamilyMembersQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetPassholdersPassholderIdFamilyMembers<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdFamilyMembers<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdFamilyMembers<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve family members of the current passholder
 */

export function useGetPassholdersPassholderIdFamilyMembers<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilyMembers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersPassholderIdFamilyMembersQueryOptions(passholderId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Add another passholder as a family member of the given passholder.

Specify the `uitpasNumber` and optionally an `icon` for the new family member.

The caller of this method must have `PASSHOLDERS_FAMILY_MEMBERS` permission for the given passholder.

If a user access token of a passholder is used (e.g. in an end-user application), an extra `x-registration-header` header is required containing the registration token of the new family member. Use [GET /passholders/me/uitid/registration-token](/reference/uitpas.json/paths/~1passholders~1me~1uitid~1registration-token/get) to retrieve a registration token.

If an admin user token or client access token with the appropriate permissions is used, the `x-registration-token` header can be ommitted.
 * @summary Add family members to the current passholder's family
 */
export type postPassholdersPassholderIdFamilyMembersResponse201 = {
  data: void
  status: 201
}

export type postPassholdersPassholderIdFamilyMembersResponse400 = {
  data: Error
  status: 400
}

export type postPassholdersPassholderIdFamilyMembersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type postPassholdersPassholderIdFamilyMembersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type postPassholdersPassholderIdFamilyMembersResponse404 = {
  data: Error
  status: 404
}

export type postPassholdersPassholderIdFamilyMembersResponseSuccess = (postPassholdersPassholderIdFamilyMembersResponse201) & {
  headers: Headers;
};
export type postPassholdersPassholderIdFamilyMembersResponseError = (postPassholdersPassholderIdFamilyMembersResponse400 | postPassholdersPassholderIdFamilyMembersResponse401 | postPassholdersPassholderIdFamilyMembersResponse403 | postPassholdersPassholderIdFamilyMembersResponse404) & {
  headers: Headers;
};

export type postPassholdersPassholderIdFamilyMembersResponse = (postPassholdersPassholderIdFamilyMembersResponseSuccess | postPassholdersPassholderIdFamilyMembersResponseError)

export const getPostPassholdersPassholderIdFamilyMembersUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/family-members`
}

export const postPassholdersPassholderIdFamilyMembers = async (passholderId: string,
    familyMember: NonReadonly<FamilyMember>, options?: RequestInit): Promise<postPassholdersPassholderIdFamilyMembersResponse> => {
  
  const res = await fetch(getPostPassholdersPassholderIdFamilyMembersUrl(passholderId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      familyMember,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postPassholdersPassholderIdFamilyMembersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postPassholdersPassholderIdFamilyMembersResponse
}
  



export const getPostPassholdersPassholderIdFamilyMembersMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholdersPassholderIdFamilyMembers>>, TError,{passholderId: string;data: NonReadonly<FamilyMember>}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postPassholdersPassholderIdFamilyMembers>>, TError,{passholderId: string;data: NonReadonly<FamilyMember>}, TContext> => {

const mutationKey = ['postPassholdersPassholderIdFamilyMembers'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPassholdersPassholderIdFamilyMembers>>, {passholderId: string;data: NonReadonly<FamilyMember>}> = (props) => {
          const {passholderId,data} = props ?? {};

          return  postPassholdersPassholderIdFamilyMembers(passholderId,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostPassholdersPassholderIdFamilyMembersMutationResult = NonNullable<Awaited<ReturnType<typeof postPassholdersPassholderIdFamilyMembers>>>
    export type PostPassholdersPassholderIdFamilyMembersMutationBody = NonReadonly<FamilyMember>
    export type PostPassholdersPassholderIdFamilyMembersMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Add family members to the current passholder's family
 */
export const usePostPassholdersPassholderIdFamilyMembers = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPassholdersPassholderIdFamilyMembers>>, TError,{passholderId: string;data: NonReadonly<FamilyMember>}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPassholdersPassholderIdFamilyMembers>>,
        TError,
        {passholderId: string;data: NonReadonly<FamilyMember>},
        TContext
      > => {
      return useMutation(getPostPassholdersPassholderIdFamilyMembersMutationOptions(options), queryClient);
    }
    /**
 * Update information of a family member of the given passholder.

The caller of this method must have `PASSHOLDERS_FAMILY_MEMBERS` permission for the given passholder

 * @summary Update a family member
 */
export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse202 = {
  data: void
  status: 202
}

export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse400 = {
  data: Error
  status: 400
}

export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse404 = {
  data: Error
  status: 404
}

export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponseSuccess = (putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse202) & {
  headers: Headers;
};
export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponseError = (putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse400 | putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse401 | putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse403 | putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse404) & {
  headers: Headers;
};

export type putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse = (putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponseSuccess | putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponseError)

export const getPutPassholdersPassholderIdFamilyMembersFamilyMemberIdUrl = (passholderId: string,
    familyMemberId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/family-members/${familyMemberId}`
}

export const putPassholdersPassholderIdFamilyMembersFamilyMemberId = async (passholderId: string,
    familyMemberId: string,
    familyMember: NonReadonly<FamilyMember>, options?: RequestInit): Promise<putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse> => {
  
  const res = await fetch(getPutPassholdersPassholderIdFamilyMembersFamilyMemberIdUrl(passholderId,familyMemberId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      familyMember,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putPassholdersPassholderIdFamilyMembersFamilyMemberIdResponse
}
  



export const getPutPassholdersPassholderIdFamilyMembersFamilyMemberIdMutationOptions = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPassholdersPassholderIdFamilyMembersFamilyMemberId>>, TError,{passholderId: string;familyMemberId: string;data: NonReadonly<FamilyMember>}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putPassholdersPassholderIdFamilyMembersFamilyMemberId>>, TError,{passholderId: string;familyMemberId: string;data: NonReadonly<FamilyMember>}, TContext> => {

const mutationKey = ['putPassholdersPassholderIdFamilyMembersFamilyMemberId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPassholdersPassholderIdFamilyMembersFamilyMemberId>>, {passholderId: string;familyMemberId: string;data: NonReadonly<FamilyMember>}> = (props) => {
          const {passholderId,familyMemberId,data} = props ?? {};

          return  putPassholdersPassholderIdFamilyMembersFamilyMemberId(passholderId,familyMemberId,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutPassholdersPassholderIdFamilyMembersFamilyMemberIdMutationResult = NonNullable<Awaited<ReturnType<typeof putPassholdersPassholderIdFamilyMembersFamilyMemberId>>>
    export type PutPassholdersPassholderIdFamilyMembersFamilyMemberIdMutationBody = NonReadonly<FamilyMember>
    export type PutPassholdersPassholderIdFamilyMembersFamilyMemberIdMutationError = Error | UnauthorizedResponse | ForbiddenResponse

    /**
 * @summary Update a family member
 */
export const usePutPassholdersPassholderIdFamilyMembersFamilyMemberId = <TError = Error | UnauthorizedResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPassholdersPassholderIdFamilyMembersFamilyMemberId>>, TError,{passholderId: string;familyMemberId: string;data: NonReadonly<FamilyMember>}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPassholdersPassholderIdFamilyMembersFamilyMemberId>>,
        TError,
        {passholderId: string;familyMemberId: string;data: NonReadonly<FamilyMember>},
        TContext
      > => {
      return useMutation(getPutPassholdersPassholderIdFamilyMembersFamilyMemberIdMutationOptions(options), queryClient);
    }
    /**
 * Delete a family member of a given passholder.

The main family member is always a member of their family (boolean `mainFamilyMember` is `true`) and cannot be deleted.

The caller of this method must have `PASSHOLDERS_FAMILY_MEMBERS` permission for the *main family member* or for the *to be deleted family member*, except for custom token authentication.


<!-- theme: info -->

> Custom tokens
>
> Next to regular client and user access tokens, this endpoint also supports 'custom tokens'. In this scenario, the custom token is sent out in an email to the passholder, who is added as a family member. This allows for the reversal of the add operation directly from that email, without further authentication. Unless your client is implementing this  flow, you can ignore custom tokens.
 * @summary Delete a family member
 */
export type deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse202 = {
  data: void
  status: 202
}

export type deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse404 = {
  data: Error
  status: 404
}

export type deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponseSuccess = (deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse202) & {
  headers: Headers;
};
export type deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponseError = (deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse401 | deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse403 | deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse404) & {
  headers: Headers;
};

export type deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse = (deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponseSuccess | deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponseError)

export const getDeletePassholdersPassholderIdFamilyMembersFamilyMemberIdUrl = (passholderId: string,
    familyMemberId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/family-members/${familyMemberId}`
}

export const deletePassholdersPassholderIdFamilyMembersFamilyMemberId = async (passholderId: string,
    familyMemberId: string, options?: RequestInit): Promise<deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse> => {
  
  const res = await fetch(getDeletePassholdersPassholderIdFamilyMembersFamilyMemberIdUrl(passholderId,familyMemberId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deletePassholdersPassholderIdFamilyMembersFamilyMemberIdResponse
}
  



export const getDeletePassholdersPassholderIdFamilyMembersFamilyMemberIdMutationOptions = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersPassholderIdFamilyMembersFamilyMemberId>>, TError,{passholderId: string;familyMemberId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersPassholderIdFamilyMembersFamilyMemberId>>, TError,{passholderId: string;familyMemberId: string}, TContext> => {

const mutationKey = ['deletePassholdersPassholderIdFamilyMembersFamilyMemberId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePassholdersPassholderIdFamilyMembersFamilyMemberId>>, {passholderId: string;familyMemberId: string}> = (props) => {
          const {passholderId,familyMemberId} = props ?? {};

          return  deletePassholdersPassholderIdFamilyMembersFamilyMemberId(passholderId,familyMemberId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePassholdersPassholderIdFamilyMembersFamilyMemberIdMutationResult = NonNullable<Awaited<ReturnType<typeof deletePassholdersPassholderIdFamilyMembersFamilyMemberId>>>
    
    export type DeletePassholdersPassholderIdFamilyMembersFamilyMemberIdMutationError = UnauthorizedResponse | ForbiddenResponse | Error

    /**
 * @summary Delete a family member
 */
export const useDeletePassholdersPassholderIdFamilyMembersFamilyMemberId = <TError = UnauthorizedResponse | ForbiddenResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePassholdersPassholderIdFamilyMembersFamilyMemberId>>, TError,{passholderId: string;familyMemberId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePassholdersPassholderIdFamilyMembersFamilyMemberId>>,
        TError,
        {passholderId: string;familyMemberId: string},
        TContext
      > => {
      return useMutation(getDeletePassholdersPassholderIdFamilyMembersFamilyMemberIdMutationOptions(options), queryClient);
    }
    /**
 * Retrieve the other families to which the given passholder was added. This explicitly excludes the passholder's own family.

The caller of this method must have `PASSHOLDERS_FAMILY_MEMBERS` permission for the given passholder.
 * @summary Retrieve families of the current passholder
 */
export type getPassholdersPassholderIdFamiliesResponse200 = {
  data: GetPassholdersPassholderIdFamilies200Item[]
  status: 200
}

export type getPassholdersPassholderIdFamiliesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getPassholdersPassholderIdFamiliesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getPassholdersPassholderIdFamiliesResponse404 = {
  data: Error
  status: 404
}

export type getPassholdersPassholderIdFamiliesResponseSuccess = (getPassholdersPassholderIdFamiliesResponse200) & {
  headers: Headers;
};
export type getPassholdersPassholderIdFamiliesResponseError = (getPassholdersPassholderIdFamiliesResponse401 | getPassholdersPassholderIdFamiliesResponse403 | getPassholdersPassholderIdFamiliesResponse404) & {
  headers: Headers;
};

export type getPassholdersPassholderIdFamiliesResponse = (getPassholdersPassholderIdFamiliesResponseSuccess | getPassholdersPassholderIdFamiliesResponseError)

export const getGetPassholdersPassholderIdFamiliesUrl = (passholderId: string,) => {


  

  return `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/families`
}

export const getPassholdersPassholderIdFamilies = async (passholderId: string, options?: RequestInit): Promise<getPassholdersPassholderIdFamiliesResponse> => {
  
  const res = await fetch(getGetPassholdersPassholderIdFamiliesUrl(passholderId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassholdersPassholderIdFamiliesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassholdersPassholderIdFamiliesResponse
}
  




export const getGetPassholdersPassholderIdFamiliesQueryKey = (passholderId: string,) => {
    return [
    `NEXT_PUBLIC_API_PATH/passholders/${passholderId}/families`
    ] as const;
    }

    
export const getGetPassholdersPassholderIdFamiliesQueryOptions = <TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPassholdersPassholderIdFamiliesQueryKey(passholderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>> = ({ signal }) => getPassholdersPassholderIdFamilies(passholderId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(passholderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPassholdersPassholderIdFamiliesQueryResult = NonNullable<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>>
export type GetPassholdersPassholderIdFamiliesQueryError = UnauthorizedResponse | ForbiddenResponse | Error


export function useGetPassholdersPassholderIdFamilies<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdFamilies<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>,
          TError,
          Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPassholdersPassholderIdFamilies<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve families of the current passholder
 */

export function useGetPassholdersPassholderIdFamilies<TData = Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError = UnauthorizedResponse | ForbiddenResponse | Error>(
 passholderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPassholdersPassholderIdFamilies>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPassholdersPassholderIdFamiliesQueryOptions(passholderId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




