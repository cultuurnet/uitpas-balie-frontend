/**
 * Generated by orval v6.19.1 üç∫
 * Do not edit manually.
 * Entry API
 * With UiTdatabank's Entry API you can create new events, places and organizers, and add extra info to them with specific requests to add/update properties. For example there are operations to add a label, remove a label, add an image, and so on.
 * OpenAPI spec version: 3.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  EventAttendanceModePut,
  EventAttendanceModePut400,
  EventAudience,
  EventAudiencePut400,
  EventAvailableFromPut,
  EventAvailableFromPut400,
  EventBookingAvailability,
  EventBookingAvailabilityPut400,
  EventBookingInfo,
  EventBookingInfoPut400,
  EventCalendarPut400,
  EventCalendarPutBody,
  EventCalendarSummaryGetParams,
  EventContactPointPut,
  EventContactPointPut400,
  EventCopiesPost201,
  EventCopiesPost400,
  EventCopiesPostBody,
  EventDescriptionPut,
  EventDescriptionPut400,
  EventFacilitiesPut,
  EventFacilitiesPut400,
  EventImagePost,
  EventImagePut,
  EventImagePut400,
  EventImagesPost400,
  EventImportNew201,
  EventImportNew400,
  EventImportUpdate200,
  EventImportUpdate400,
  EventLocationPut400,
  EventMainImagePut,
  EventMainImagePut400,
  EventMajorInfoPut400,
  EventMajorInfoPutBody,
  EventNamePut,
  EventNamePut400,
  EventOnlineUrlPut,
  EventOnlineUrlPut400,
  EventPost,
  EventPost201,
  EventPost400,
  EventPriceInfo,
  EventPriceInfoPut400,
  EventPut200,
  EventPut400,
  EventStatus,
  EventStatusPut400,
  EventSubEventPatch,
  EventSubEventPatch400,
  EventTypicalAgeRangePut,
  EventTypicalAgeRangePut400,
  EventVideosPatch,
  EventVideosPatch400,
  EventVideosPost,
  EventVideosPost200,
  EventVideosPost400,
  EventWithReadExample,
  EventWithWriteExample,
  EventWorkflowStatusPut,
  EventWorkflowStatusPut400,
  ForbiddenResponse,
  NotFoundResponse,
  UnauthorizedResponse
} from '.././model'



/**
 * Creates a new event with the required properties and any additional optional properties.

By default, the new event will be editable and removable by the user or client that the access token used to perform this request belongs to. If you use a user access token, the user for which the token was obtained will see the new event in their dashboard in UiTdatabank and will be able to edit or remove it. If you use a client access token, only API requests with a token for the same client will be able to edit or remove it.
 * @summary event - create
 */
export const eventPost = (
    eventPost: EventPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventPost201>> => {
    
    return axios.post(
      `NEXT_PUBLIC_ENTRY_API_PATH/events`,
      eventPost,options
    );
  }



export const getEventPostMutationOptions = <TError = AxiosError<EventPost400 | UnauthorizedResponse | ForbiddenResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventPost>>, TError,{data: EventPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventPost>>, TError,{data: EventPost}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventPost>>, {data: EventPost}> = (props) => {
          const {data} = props ?? {};

          return  eventPost(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventPostMutationResult = NonNullable<Awaited<ReturnType<typeof eventPost>>>
    export type EventPostMutationBody = EventPost
    export type EventPostMutationError = AxiosError<EventPost400 | UnauthorizedResponse | ForbiddenResponse>

    /**
 * @summary event - create
 */
export const useEventPost = <TError = AxiosError<EventPost400 | UnauthorizedResponse | ForbiddenResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventPost>>, TError,{data: EventPost}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Returns the details of the event for the given `eventId`.
 * @summary event - get
 */
export const eventGet = (
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventWithReadExample>> => {
    
    return axios.get(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}`,options
    );
  }


export const getEventGetQueryKey = (eventId: string,) => {
    
    return [`NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}`] as const;
    }

    
export const getEventGetQueryOptions = <TData = Awaited<ReturnType<typeof eventGet>>, TError = AxiosError<NotFoundResponse>>(eventId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof eventGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventGetQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventGet>>> = ({ signal }) => eventGet(eventId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventGet>>, TError, TData> & { queryKey: QueryKey }
}

export type EventGetQueryResult = NonNullable<Awaited<ReturnType<typeof eventGet>>>
export type EventGetQueryError = AxiosError<NotFoundResponse>

/**
 * @summary event - get
 */
export const useEventGet = <TData = Awaited<ReturnType<typeof eventGet>>, TError = AxiosError<NotFoundResponse>>(
 eventId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof eventGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getEventGetQueryOptions(eventId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

/**
 * Updates the event with the given `eventId` by completely overwriting it with the properties in the given JSON. 

<!-- theme: danger -->

> Any existing optional properties on the event that are not included in the update request will be removed from the event when updating the event via this operation.
>
> As an exception, some existing `labels` or `hiddenLabels` may be kept on the event even if they are not included in the update request. For example if they were added via the UiTdatabank UI, or if the client or user making the request does not have sufficient permission to remove some specific labels.
 * @summary event - update
 */
export const eventPut = (
    eventId: string,
    eventWithWriteExample: EventWithWriteExample, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventPut200>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}`,
      eventWithWriteExample,options
    );
  }



export const getEventPutMutationOptions = <TError = AxiosError<EventPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventPut>>, TError,{eventId: string;data: EventWithWriteExample}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventPut>>, TError,{eventId: string;data: EventWithWriteExample}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventPut>>, {eventId: string;data: EventWithWriteExample}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventPut>>>
    export type EventPutMutationBody = EventWithWriteExample
    export type EventPutMutationError = AxiosError<EventPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary event - update
 */
export const useEventPut = <TError = AxiosError<EventPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventPut>>, TError,{eventId: string;data: EventWithWriteExample}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Does a soft-delete of the event. The event will continue to exist but it's `workflowStatus` will be changed to `DELETED`. This will remove it from all publication channels.
 * @summary event - delete
 */
export const eventDelete = (
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}`,options
    );
  }



export const getEventDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventDelete>>, TError,{eventId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventDelete>>, {eventId: string}> = (props) => {
          const {eventId} = props ?? {};

          return  eventDelete(eventId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventDelete>>>
    
    export type EventDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary event - delete
 */
export const useEventDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Creates a new event via the historical `/imports/events` URL.

<!-- theme: danger -->

> This operation is deprecated and should not be used in new integrations. Use the [`POST /events`](./entry.json/paths/~1events/post) operation instead to create new events.
>
> Both operations accept the same JSON bodies nowadays, and support creating events with only the required properties or with additional optional properties.
>
> The only difference is that the default `workflowStatus` for events created via [`POST /events`](./entry.json/paths/~1events/post) is `DRAFT`, while new events created via this `POST /imports/events` operation will have the default workflowStatus `READY_FOR_VALIDATION` for backward compatibility with historical integrations.
>
> If you want your new events to also have the workflowStatus `READY_FOR_VALIDATION`, you can use the [`POST /events`](./entry.json/paths/~1events/post) operation and explicitly set the `workflowStatus` property in your JSON body to `READY_FOR_VALIDATION`.
 * @deprecated
 * @summary event - import (create)
 */
export const eventImportNew = (
    eventPost: EventPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventImportNew201>> => {
    
    return axios.post(
      `NEXT_PUBLIC_ENTRY_API_PATH/imports/events`,
      eventPost,options
    );
  }



export const getEventImportNewMutationOptions = <TError = AxiosError<EventImportNew400 | UnauthorizedResponse | ForbiddenResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImportNew>>, TError,{data: EventPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventImportNew>>, TError,{data: EventPost}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventImportNew>>, {data: EventPost}> = (props) => {
          const {data} = props ?? {};

          return  eventImportNew(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventImportNewMutationResult = NonNullable<Awaited<ReturnType<typeof eventImportNew>>>
    export type EventImportNewMutationBody = EventPost
    export type EventImportNewMutationError = AxiosError<EventImportNew400 | UnauthorizedResponse | ForbiddenResponse>

    /**
 * @deprecated
 * @summary event - import (create)
 */
export const useEventImportNew = <TError = AxiosError<EventImportNew400 | UnauthorizedResponse | ForbiddenResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImportNew>>, TError,{data: EventPost}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventImportNewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the event via the historical `/imports/events/{eventId}` URL by completely overwriting it with the properties in the given JSON. 

<!-- theme: danger -->

> This operation is deprecated and should not be used in new integrations. Use the [`PUT /events/{eventId}`](./entry.json/paths/~1events~1{eventId}/put) operation instead to update existing events, which accepts exactly the same JSON body.
 * @deprecated
 * @summary event - import (update)
 */
export const eventImportUpdate = (
    eventId: string,
    eventWithWriteExample: EventWithWriteExample, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventImportUpdate200>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/imports/events/${eventId}`,
      eventWithWriteExample,options
    );
  }



export const getEventImportUpdateMutationOptions = <TError = AxiosError<EventImportUpdate400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImportUpdate>>, TError,{eventId: string;data: EventWithWriteExample}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventImportUpdate>>, TError,{eventId: string;data: EventWithWriteExample}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventImportUpdate>>, {eventId: string;data: EventWithWriteExample}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventImportUpdate(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventImportUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof eventImportUpdate>>>
    export type EventImportUpdateMutationBody = EventWithWriteExample
    export type EventImportUpdateMutationError = AxiosError<EventImportUpdate400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @deprecated
 * @summary event - import (update)
 */
export const useEventImportUpdate = <TError = AxiosError<EventImportUpdate400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImportUpdate>>, TError,{eventId: string;data: EventWithWriteExample}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventImportUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Creates a new event based on all the properties of an existing event with the given `eventId`. Only the calendar information will be completely replaced with a new one, which has to be included in the request body.

The schema of the request body is the same as the one for the [`PUT /events/{eventId}/calendar`](/reference/entry.json/paths/~1events~1{eventId}~1calendar/put) endpoint.
 * @summary event - copy
 */
export const eventCopiesPost = (
    eventId: string,
    eventCopiesPostBody: EventCopiesPostBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventCopiesPost201>> => {
    
    return axios.post(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/copies`,
      eventCopiesPostBody,options
    );
  }



export const getEventCopiesPostMutationOptions = <TError = AxiosError<EventCopiesPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventCopiesPost>>, TError,{eventId: string;data: EventCopiesPostBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventCopiesPost>>, TError,{eventId: string;data: EventCopiesPostBody}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventCopiesPost>>, {eventId: string;data: EventCopiesPostBody}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventCopiesPost(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventCopiesPostMutationResult = NonNullable<Awaited<ReturnType<typeof eventCopiesPost>>>
    export type EventCopiesPostMutationBody = EventCopiesPostBody
    export type EventCopiesPostMutationError = AxiosError<EventCopiesPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary event - copy
 */
export const useEventCopiesPost = <TError = AxiosError<EventCopiesPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventCopiesPost>>, TError,{eventId: string;data: EventCopiesPostBody}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventCopiesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the attendance mode of an event. There are three different attendance modes:
- `offline`: the event takes places on a physical location
- `online`: the events takes places on an online location
- `mixed`: the event takes places both on a real location and a online location

When changing from attendance mode online to either offline or mixed it is required to include the location property with the URI or UUID of the (physical) [location](/models/place.json) that the event is taking place at.
 * @summary attendanceMode - update
 */
export const eventAttendanceModePut = (
    eventId: string,
    eventAttendanceModePut: EventAttendanceModePut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/attendance-mode`,
      eventAttendanceModePut,options
    );
  }



export const getEventAttendanceModePutMutationOptions = <TError = AxiosError<EventAttendanceModePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventAttendanceModePut>>, TError,{eventId: string;data: EventAttendanceModePut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventAttendanceModePut>>, TError,{eventId: string;data: EventAttendanceModePut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventAttendanceModePut>>, {eventId: string;data: EventAttendanceModePut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventAttendanceModePut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventAttendanceModePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventAttendanceModePut>>>
    export type EventAttendanceModePutMutationBody = EventAttendanceModePut
    export type EventAttendanceModePutMutationError = AxiosError<EventAttendanceModePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary attendanceMode - update
 */
export const useEventAttendanceModePut = <TError = AxiosError<EventAttendanceModePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventAttendanceModePut>>, TError,{eventId: string;data: EventAttendanceModePut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventAttendanceModePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the intended audience of the event, which currently only has one property `audienceType`. 

By default the audienceType is set to `everyone`. If needed the audience can be updated to `members` to hide it on public channels, or `education` for CultuurKuur events for schools.
 * @summary audience - update
 */
export const eventAudiencePut = (
    eventId: string,
    eventAudience: EventAudience, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/audience`,
      eventAudience,options
    );
  }



export const getEventAudiencePutMutationOptions = <TError = AxiosError<EventAudiencePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventAudiencePut>>, TError,{eventId: string;data: EventAudience}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventAudiencePut>>, TError,{eventId: string;data: EventAudience}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventAudiencePut>>, {eventId: string;data: EventAudience}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventAudiencePut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventAudiencePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventAudiencePut>>>
    export type EventAudiencePutMutationBody = EventAudience
    export type EventAudiencePutMutationError = AxiosError<EventAudiencePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary audience - update
 */
export const useEventAudiencePut = <TError = AxiosError<EventAudiencePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventAudiencePut>>, TError,{eventId: string;data: EventAudience}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventAudiencePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the availableFrom of the event. This is the first date & time that the event is allowed to be visible on publication channels.
 * @summary availableFrom - update
 */
export const eventAvailableFromPut = (
    eventId: string,
    eventAvailableFromPut: EventAvailableFromPut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/available-from`,
      eventAvailableFromPut,options
    );
  }



export const getEventAvailableFromPutMutationOptions = <TError = AxiosError<EventAvailableFromPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventAvailableFromPut>>, TError,{eventId: string;data: EventAvailableFromPut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventAvailableFromPut>>, TError,{eventId: string;data: EventAvailableFromPut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventAvailableFromPut>>, {eventId: string;data: EventAvailableFromPut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventAvailableFromPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventAvailableFromPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventAvailableFromPut>>>
    export type EventAvailableFromPutMutationBody = EventAvailableFromPut
    export type EventAvailableFromPutMutationError = AxiosError<EventAvailableFromPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary availableFrom - update
 */
export const useEventAvailableFromPut = <TError = AxiosError<EventAvailableFromPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventAvailableFromPut>>, TError,{eventId: string;data: EventAvailableFromPut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventAvailableFromPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the general bookingAvailability info on the top level of the event with the given `eventId`.

The bookingAvailability of any subEvents that the event has will also be updated to match the general bookingAvailability.

<!-- theme: warning -->

> Note that you cannot update the bookingAvailability of an event with [calendar type](/models/event-calendarType.json) `periodic` or `permanent`. For now, they can only have "Available" as bookingAvailability.
 * @summary bookingAvailability - update
 */
export const eventBookingAvailabilityPut = (
    eventId: string,
    eventBookingAvailability: EventBookingAvailability, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/booking-availability`,
      eventBookingAvailability,options
    );
  }



export const getEventBookingAvailabilityPutMutationOptions = <TError = AxiosError<EventBookingAvailabilityPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBookingAvailabilityPut>>, TError,{eventId: string;data: EventBookingAvailability}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventBookingAvailabilityPut>>, TError,{eventId: string;data: EventBookingAvailability}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventBookingAvailabilityPut>>, {eventId: string;data: EventBookingAvailability}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventBookingAvailabilityPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventBookingAvailabilityPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventBookingAvailabilityPut>>>
    export type EventBookingAvailabilityPutMutationBody = EventBookingAvailability
    export type EventBookingAvailabilityPutMutationError = AxiosError<EventBookingAvailabilityPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary bookingAvailability - update
 */
export const useEventBookingAvailabilityPut = <TError = AxiosError<EventBookingAvailabilityPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBookingAvailabilityPut>>, TError,{eventId: string;data: EventBookingAvailability}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventBookingAvailabilityPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the bookingInfo for an event.

<!-- theme: info -->

> There is no DELETE endpoint. To remove (specific) bookingInfo perform a PUT request with empty properties.
 * @summary bookingInfo - update
 */
export const eventBookingInfoPut = (
    eventId: string,
    eventBookingInfo: EventBookingInfo, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/booking-info`,
      eventBookingInfo,options
    );
  }



export const getEventBookingInfoPutMutationOptions = <TError = AxiosError<EventBookingInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBookingInfoPut>>, TError,{eventId: string;data: EventBookingInfo}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventBookingInfoPut>>, TError,{eventId: string;data: EventBookingInfo}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventBookingInfoPut>>, {eventId: string;data: EventBookingInfo}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventBookingInfoPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventBookingInfoPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventBookingInfoPut>>>
    export type EventBookingInfoPutMutationBody = EventBookingInfo
    export type EventBookingInfoPutMutationError = AxiosError<EventBookingInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary bookingInfo - update
 */
export const useEventBookingInfoPut = <TError = AxiosError<EventBookingInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBookingInfoPut>>, TError,{eventId: string;data: EventBookingInfo}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventBookingInfoPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the calendar information of the given `eventId`. The calendar information will be completely replaced with the new one.

The required properties depend on the `calendarType` property.

| calendarType  | required  | optional  |
|---|---|---|
| single  | subEvent\[0\].startDate, subEvent\[0\].endDate | subEvent\[0\].status, subEvent\[0\].bookingAvailability  |
| multiple  | subEvent\[\*\].startDate, subEvent[\*\].endDate  | subEvent\[\*\].status, subEvent\[\*\].bookingAvailability  |
| periodic  | startDate, endDate  | openingHours, status, bookingAvailability  |
| permanent  |   | openingHours, status, bookingAvailability  |

<!-- theme: warning -->

> If `status` or `bookingAvailability` is missing on the event or a subEvent, it will default to `Available`.
>
> Although the status and bookingAvailability are optional they have a default value of `Available`. When the status and bookingAvailability is not provided an already set value will be overwritten to `Available`!

<!-- theme: success -->

> You can use `single` and `multiple` interchangeably as long as you also include `subEvent` as well. The API will use the correct type based on the number of subEvents inside `subEvent`.

<!-- theme: info -->

> This endpoint also supports a deprecated schema that uses `timeSpans` instead of `subEvent`. The `timeSpans` also have a slightly different structure than `subEvent`. For new integrations, it is recommended to use the schema with the `subEvent` property. 
> 
> For existing integrations the `timeSpans` property will be supported indefinitely for backward compatibility.
 * @summary calendar - put
 */
export const eventCalendarPut = (
    eventId: string,
    eventCalendarPutBody: EventCalendarPutBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/calendar`,
      eventCalendarPutBody,options
    );
  }



export const getEventCalendarPutMutationOptions = <TError = AxiosError<EventCalendarPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventCalendarPut>>, TError,{eventId: string;data: EventCalendarPutBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventCalendarPut>>, TError,{eventId: string;data: EventCalendarPutBody}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventCalendarPut>>, {eventId: string;data: EventCalendarPutBody}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventCalendarPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventCalendarPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventCalendarPut>>>
    export type EventCalendarPutMutationBody = EventCalendarPutBody
    export type EventCalendarPutMutationError = AxiosError<EventCalendarPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary calendar - put
 */
export const useEventCalendarPut = <TError = AxiosError<EventCalendarPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventCalendarPut>>, TError,{eventId: string;data: EventCalendarPutBody}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventCalendarPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Returns a human-readable summary of the calendar information of the event. Can be configured to return either plain text or HTML, and to switch between four different formats depending on the amount of space you have to display it.

> For backward compatibility this endpoint is also accessible at the old abbreviated `/events/{eventId}/calsum` path.
 * @summary calendar summary - get
 */
export const eventCalendarSummaryGet = (
    eventId: string,
    params?: EventCalendarSummaryGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/calendar-summary`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getEventCalendarSummaryGetQueryKey = (eventId: string,
    params?: EventCalendarSummaryGetParams,) => {
    
    return [`NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/calendar-summary`, ...(params ? [params]: [])] as const;
    }

    
export const getEventCalendarSummaryGetQueryOptions = <TData = Awaited<ReturnType<typeof eventCalendarSummaryGet>>, TError = AxiosError<NotFoundResponse>>(eventId: string,
    params?: EventCalendarSummaryGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof eventCalendarSummaryGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventCalendarSummaryGetQueryKey(eventId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventCalendarSummaryGet>>> = ({ signal }) => eventCalendarSummaryGet(eventId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventCalendarSummaryGet>>, TError, TData> & { queryKey: QueryKey }
}

export type EventCalendarSummaryGetQueryResult = NonNullable<Awaited<ReturnType<typeof eventCalendarSummaryGet>>>
export type EventCalendarSummaryGetQueryError = AxiosError<NotFoundResponse>

/**
 * @summary calendar summary - get
 */
export const useEventCalendarSummaryGet = <TData = Awaited<ReturnType<typeof eventCalendarSummaryGet>>, TError = AxiosError<NotFoundResponse>>(
 eventId: string,
    params?: EventCalendarSummaryGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof eventCalendarSummaryGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getEventCalendarSummaryGetQueryOptions(eventId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

/**
 * Updates the contact point information of the event with the given `eventId`.

<!-- theme: info -->

> There is no DELETE endpoint. To remove contact information perform a PUT request with empty properties.

<!-- theme: warning -->

> Unlike [`PUT /organizers/{organizerId}/contact-point`](./entry.json/paths/~1organizers~1{organizerId}~1contact-point/put), all properties are required. There is also no partial updating.
 * @summary contactPoint - update
 */
export const eventContactPointPut = (
    eventId: string,
    eventContactPointPut: EventContactPointPut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/contact-point`,
      eventContactPointPut,options
    );
  }



export const getEventContactPointPutMutationOptions = <TError = AxiosError<EventContactPointPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventContactPointPut>>, TError,{eventId: string;data: EventContactPointPut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventContactPointPut>>, TError,{eventId: string;data: EventContactPointPut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventContactPointPut>>, {eventId: string;data: EventContactPointPut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventContactPointPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventContactPointPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventContactPointPut>>>
    export type EventContactPointPutMutationBody = EventContactPointPut
    export type EventContactPointPutMutationError = AxiosError<EventContactPointPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary contactPoint - update
 */
export const useEventContactPointPut = <TError = AxiosError<EventContactPointPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventContactPointPut>>, TError,{eventId: string;data: EventContactPointPut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventContactPointPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the localized description of an event based on the given `eventId` and `language` inside the URL. The description is not limited in size, but it is recommended to use the first 200 characters of the description for promotional copy as these characters are visible in the list-view of results.

<!-- theme: info -->

> Keep in mind: 
> - The description should be UTF-8 encoded 
> - Linebreaks are encoded as `\n`


 * @summary description - update
 */
export const eventDescriptionPut = (
    eventId: string,
    language: 'nl' | 'fr' | 'en' | 'de',
    eventDescriptionPut: EventDescriptionPut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/description/${language}`,
      eventDescriptionPut,options
    );
  }



export const getEventDescriptionPutMutationOptions = <TError = AxiosError<EventDescriptionPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDescriptionPut>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventDescriptionPut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventDescriptionPut>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventDescriptionPut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventDescriptionPut>>, {eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventDescriptionPut}> = (props) => {
          const {eventId,language,data} = props ?? {};

          return  eventDescriptionPut(eventId,language,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventDescriptionPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventDescriptionPut>>>
    export type EventDescriptionPutMutationBody = EventDescriptionPut
    export type EventDescriptionPutMutationError = AxiosError<EventDescriptionPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary description - update
 */
export const useEventDescriptionPut = <TError = AxiosError<EventDescriptionPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDescriptionPut>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventDescriptionPut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventDescriptionPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Deletes the localized description of an event based on the given `eventId` and `language` inside the URL. 

<!-- theme: info -->
 * @summary description - delete
 */
export const eventDescriptionDelete = (
    eventId: string,
    language: 'nl' | 'fr' | 'en' | 'de', options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/description/${language}`,options
    );
  }



export const getEventDescriptionDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDescriptionDelete>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de'}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventDescriptionDelete>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de'}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventDescriptionDelete>>, {eventId: string;language: 'nl' | 'fr' | 'en' | 'de'}> = (props) => {
          const {eventId,language} = props ?? {};

          return  eventDescriptionDelete(eventId,language,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventDescriptionDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventDescriptionDelete>>>
    
    export type EventDescriptionDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary description - delete
 */
export const useEventDescriptionDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDescriptionDelete>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de'}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventDescriptionDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the list of available (accessibility) facilities on the event. These will show up in the [event's `terms`](/models/event-terms.json).

A list of possible facilities can be found using our [guide about taxonomy terms](../docs/taxonomy-api/terms.md).

**Note**: A special permission is required to update an event's facilities in UiTdatabank, even if you are the event owner. Contact an administrator for further information.
 * @summary facilities - update
 */
export const eventFacilitiesPut = (
    eventId: string,
    eventFacilitiesPut: EventFacilitiesPut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/facilities`,
      eventFacilitiesPut,options
    );
  }



export const getEventFacilitiesPutMutationOptions = <TError = AxiosError<EventFacilitiesPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventFacilitiesPut>>, TError,{eventId: string;data: EventFacilitiesPut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventFacilitiesPut>>, TError,{eventId: string;data: EventFacilitiesPut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventFacilitiesPut>>, {eventId: string;data: EventFacilitiesPut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventFacilitiesPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventFacilitiesPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventFacilitiesPut>>>
    export type EventFacilitiesPutMutationBody = EventFacilitiesPut
    export type EventFacilitiesPutMutationError = AxiosError<EventFacilitiesPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary facilities - update
 */
export const useEventFacilitiesPut = <TError = AxiosError<EventFacilitiesPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventFacilitiesPut>>, TError,{eventId: string;data: EventFacilitiesPut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventFacilitiesPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Adds an image to an event. To upload an image, use the [`POST /images`](./entry.json/paths/~1images/post) endpoint.
 * @summary images - add
 */
export const eventImagesPost = (
    eventId: string,
    eventImagePost: EventImagePost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/images`,
      eventImagePost,options
    );
  }



export const getEventImagesPostMutationOptions = <TError = AxiosError<EventImagesPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImagesPost>>, TError,{eventId: string;data: EventImagePost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventImagesPost>>, TError,{eventId: string;data: EventImagePost}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventImagesPost>>, {eventId: string;data: EventImagePost}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventImagesPost(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventImagesPostMutationResult = NonNullable<Awaited<ReturnType<typeof eventImagesPost>>>
    export type EventImagesPostMutationBody = EventImagePost
    export type EventImagesPostMutationError = AxiosError<EventImagesPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary images - add
 */
export const useEventImagesPost = <TError = AxiosError<EventImagesPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImagesPost>>, TError,{eventId: string;data: EventImagePost}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventImagesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Removes the image with the given `imageId` from the event's `mediaObject` property.
 * @summary images - delete
 */
export const eventImageDelete = (
    eventId: string,
    imageId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/images/${imageId}`,options
    );
  }



export const getEventImageDeleteMutationOptions = <TError = AxiosError<ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImageDelete>>, TError,{eventId: string;imageId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventImageDelete>>, TError,{eventId: string;imageId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventImageDelete>>, {eventId: string;imageId: string}> = (props) => {
          const {eventId,imageId} = props ?? {};

          return  eventImageDelete(eventId,imageId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventImageDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventImageDelete>>>
    
    export type EventImageDeleteMutationError = AxiosError<ForbiddenResponse | NotFoundResponse>

    /**
 * @summary images - delete
 */
export const useEventImageDelete = <TError = AxiosError<ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImageDelete>>, TError,{eventId: string;imageId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventImageDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the metadata of an image on an event.
 * @summary images - update
 */
export const eventImagePut = (
    eventId: string,
    imageId: string,
    eventImagePut: EventImagePut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/images/${imageId}`,
      eventImagePut,options
    );
  }



export const getEventImagePutMutationOptions = <TError = AxiosError<EventImagePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImagePut>>, TError,{eventId: string;imageId: string;data: EventImagePut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventImagePut>>, TError,{eventId: string;imageId: string;data: EventImagePut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventImagePut>>, {eventId: string;imageId: string;data: EventImagePut}> = (props) => {
          const {eventId,imageId,data} = props ?? {};

          return  eventImagePut(eventId,imageId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventImagePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventImagePut>>>
    export type EventImagePutMutationBody = EventImagePut
    export type EventImagePutMutationError = AxiosError<EventImagePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary images - update
 */
export const useEventImagePut = <TError = AxiosError<EventImagePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventImagePut>>, TError,{eventId: string;imageId: string;data: EventImagePut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventImagePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the main image of an event. The main image is the only image shown in search-result listviews and the image more prominently displayed on event-details, when the event has multiple images.
 * @summary images main - update
 */
export const eventMainImagePut = (
    eventId: string,
    eventMainImagePut: EventMainImagePut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/images/main`,
      eventMainImagePut,options
    );
  }



export const getEventMainImagePutMutationOptions = <TError = AxiosError<EventMainImagePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventMainImagePut>>, TError,{eventId: string;data: EventMainImagePut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventMainImagePut>>, TError,{eventId: string;data: EventMainImagePut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventMainImagePut>>, {eventId: string;data: EventMainImagePut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventMainImagePut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventMainImagePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventMainImagePut>>>
    export type EventMainImagePutMutationBody = EventMainImagePut
    export type EventMainImagePutMutationError = AxiosError<EventMainImagePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary images main - update
 */
export const useEventMainImagePut = <TError = AxiosError<EventMainImagePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventMainImagePut>>, TError,{eventId: string;data: EventMainImagePut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventMainImagePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Adds the given label to the event with the given `eventId`.

If the specified label does not exist yet in UiTdatabank a new label will be created with default visibility and public permissions (usable by anyone), and linked to the event.

The label must be longer than 1 character and shorter than 255 characters. The label can also not contain the semicolon character. It should match the regex `^(?=.{2,255}$)(?=.*\S.*\S.*)[^;]*$`
 * @summary labels - add
 */
export const eventsLabelsAdd = (
    eventId: string,
    labelName: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/labels/${labelName}`,undefined,options
    );
  }



export const getEventsLabelsAddMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventsLabelsAdd>>, TError,{eventId: string;labelName: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventsLabelsAdd>>, TError,{eventId: string;labelName: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventsLabelsAdd>>, {eventId: string;labelName: string}> = (props) => {
          const {eventId,labelName} = props ?? {};

          return  eventsLabelsAdd(eventId,labelName,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventsLabelsAddMutationResult = NonNullable<Awaited<ReturnType<typeof eventsLabelsAdd>>>
    
    export type EventsLabelsAddMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary labels - add
 */
export const useEventsLabelsAdd = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventsLabelsAdd>>, TError,{eventId: string;labelName: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventsLabelsAddMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Deletes a label from the `labels` or `hiddenLabels` property on an event based on the event id, the label name, and the label's visibility.
 * @summary labels - delete
 */
export const eventLabelsDelete = (
    eventId: string,
    labelName: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/labels/${labelName}`,options
    );
  }



export const getEventLabelsDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventLabelsDelete>>, TError,{eventId: string;labelName: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventLabelsDelete>>, TError,{eventId: string;labelName: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventLabelsDelete>>, {eventId: string;labelName: string}> = (props) => {
          const {eventId,labelName} = props ?? {};

          return  eventLabelsDelete(eventId,labelName,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventLabelsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventLabelsDelete>>>
    
    export type EventLabelsDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary labels - delete
 */
export const useEventLabelsDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventLabelsDelete>>, TError,{eventId: string;labelName: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventLabelsDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the event's location to a new place based on the given `eventId` and `placeId` in the URL.

If the `eventId` does not exist a `404 Not Found` response will be returned. If the `placeId` does not exist a `400 Bad Request` response will be returned. Otherwise a `204 No Content` will be returned if successful. (See response examples below.)
 * @summary location - update
 */
export const eventLocationPut = (
    eventId: string,
    placeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/location/${placeId}`,undefined,options
    );
  }



export const getEventLocationPutMutationOptions = <TError = AxiosError<EventLocationPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventLocationPut>>, TError,{eventId: string;placeId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventLocationPut>>, TError,{eventId: string;placeId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventLocationPut>>, {eventId: string;placeId: string}> = (props) => {
          const {eventId,placeId} = props ?? {};

          return  eventLocationPut(eventId,placeId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventLocationPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventLocationPut>>>
    
    export type EventLocationPutMutationError = AxiosError<EventLocationPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary location - update
 */
export const useEventLocationPut = <TError = AxiosError<EventLocationPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventLocationPut>>, TError,{eventId: string;placeId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventLocationPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * <!-- theme: danger -->

> The major-info endpoint is deprecated and should not be used in new integrations!

Updates the "major info" of the event with the given `eventId`.

The major info contains:

* `name`: The name of the event in the event's `mainLanguage`, as a string
* `type`: Id of the event's `eventtype` taxonomy `term`, as a string
* `theme` (optional): Id of the event's `theme` taxonomy `term`, as a string
* `location`: Object with the id of the event's location, as a place's uuid (string)
* `calendar`: Object with the event's calendar information (see schema below)

All properties are required (except for `theme`) and will overwrite existing values of these properties on the event. If the event has a `theme` `term` before this update, but there is no `theme` in this major-info update, the `theme` will be removed.

<!-- theme: success -->
> For backward-compatibility with older integrations, this operation can also be requested via `POST /event/{eventId}/major-info`.
 * @deprecated
 * @summary major-info - update
 */
export const eventMajorInfoPut = (
    eventId: string,
    eventMajorInfoPutBody: EventMajorInfoPutBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/major-info`,
      eventMajorInfoPutBody,options
    );
  }



export const getEventMajorInfoPutMutationOptions = <TError = AxiosError<EventMajorInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventMajorInfoPut>>, TError,{eventId: string;data: EventMajorInfoPutBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventMajorInfoPut>>, TError,{eventId: string;data: EventMajorInfoPutBody}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventMajorInfoPut>>, {eventId: string;data: EventMajorInfoPutBody}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventMajorInfoPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventMajorInfoPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventMajorInfoPut>>>
    export type EventMajorInfoPutMutationBody = EventMajorInfoPutBody
    export type EventMajorInfoPutMutationError = AxiosError<EventMajorInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @deprecated
 * @summary major-info - update
 */
export const useEventMajorInfoPut = <TError = AxiosError<EventMajorInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventMajorInfoPut>>, TError,{eventId: string;data: EventMajorInfoPutBody}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventMajorInfoPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the localized name of an event based on the given `eventId` and `language` inside the URL.
 * @summary name - update
 */
export const eventNamePut = (
    eventId: string,
    language: 'nl' | 'fr' | 'en' | 'de',
    eventNamePut: EventNamePut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/name/${language}`,
      eventNamePut,options
    );
  }



export const getEventNamePutMutationOptions = <TError = AxiosError<EventNamePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventNamePut>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventNamePut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventNamePut>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventNamePut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventNamePut>>, {eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventNamePut}> = (props) => {
          const {eventId,language,data} = props ?? {};

          return  eventNamePut(eventId,language,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventNamePut>>>
    export type EventNamePutMutationBody = EventNamePut
    export type EventNamePutMutationError = AxiosError<EventNamePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary name - update
 */
export const useEventNamePut = <TError = AxiosError<EventNamePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventNamePut>>, TError,{eventId: string;language: 'nl' | 'fr' | 'en' | 'de';data: EventNamePut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventNamePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the online url of an event. Only events with attendance mode `online` or `mixed` can have an online url.
 * @summary onlineUrl - update
 */
export const eventOnlineUrlPut = (
    eventId: string,
    eventOnlineUrlPut: EventOnlineUrlPut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/online-url`,
      eventOnlineUrlPut,options
    );
  }



export const getEventOnlineUrlPutMutationOptions = <TError = AxiosError<EventOnlineUrlPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOnlineUrlPut>>, TError,{eventId: string;data: EventOnlineUrlPut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventOnlineUrlPut>>, TError,{eventId: string;data: EventOnlineUrlPut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventOnlineUrlPut>>, {eventId: string;data: EventOnlineUrlPut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventOnlineUrlPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventOnlineUrlPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventOnlineUrlPut>>>
    export type EventOnlineUrlPutMutationBody = EventOnlineUrlPut
    export type EventOnlineUrlPutMutationError = AxiosError<EventOnlineUrlPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary onlineUrl - update
 */
export const useEventOnlineUrlPut = <TError = AxiosError<EventOnlineUrlPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOnlineUrlPut>>, TError,{eventId: string;data: EventOnlineUrlPut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventOnlineUrlPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Delete the onlineUrl of an event.
 * @summary onlineUrl - delete
 */
export const eventOnlineUrlDelete = (
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/online-url`,options
    );
  }



export const getEventOnlineUrlDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOnlineUrlDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventOnlineUrlDelete>>, TError,{eventId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventOnlineUrlDelete>>, {eventId: string}> = (props) => {
          const {eventId} = props ?? {};

          return  eventOnlineUrlDelete(eventId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventOnlineUrlDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventOnlineUrlDelete>>>
    
    export type EventOnlineUrlDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary onlineUrl - delete
 */
export const useEventOnlineUrlDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOnlineUrlDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventOnlineUrlDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Deletes the organizer of the event with the given `eventId`.
 * @summary organizer - delete
 */
export const eventOrganizerDelete = (
    eventId: string,
    organizerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/organizer/${organizerId}`,options
    );
  }



export const getEventOrganizerDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOrganizerDelete>>, TError,{eventId: string;organizerId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventOrganizerDelete>>, TError,{eventId: string;organizerId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventOrganizerDelete>>, {eventId: string;organizerId: string}> = (props) => {
          const {eventId,organizerId} = props ?? {};

          return  eventOrganizerDelete(eventId,organizerId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventOrganizerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventOrganizerDelete>>>
    
    export type EventOrganizerDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary organizer - delete
 */
export const useEventOrganizerDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOrganizerDelete>>, TError,{eventId: string;organizerId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventOrganizerDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the organizer of the event with the given `eventId`. A list of organizers can be found using our [guide about finding existing organizers](/docs/entry-api/organizers/finding-and-reusing-organizers.md).

<!-- theme: info -->

> An organizer is not required on an event, and it can only have one.
 * @summary organizer - update
 */
export const eventOrganizerUpdate = (
    eventId: string,
    organizerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/organizer/${organizerId}`,undefined,options
    );
  }



export const getEventOrganizerUpdateMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOrganizerUpdate>>, TError,{eventId: string;organizerId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventOrganizerUpdate>>, TError,{eventId: string;organizerId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventOrganizerUpdate>>, {eventId: string;organizerId: string}> = (props) => {
          const {eventId,organizerId} = props ?? {};

          return  eventOrganizerUpdate(eventId,organizerId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventOrganizerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof eventOrganizerUpdate>>>
    
    export type EventOrganizerUpdateMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary organizer - update
 */
export const useEventOrganizerUpdate = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventOrganizerUpdate>>, TError,{eventId: string;organizerId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventOrganizerUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the price info of an event.
 * @summary priceInfo - update
 */
export const eventPriceInfoPut = (
    eventId: string,
    eventPriceInfo: EventPriceInfo, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/price-info`,
      eventPriceInfo,options
    );
  }



export const getEventPriceInfoPutMutationOptions = <TError = AxiosError<EventPriceInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventPriceInfoPut>>, TError,{eventId: string;data: EventPriceInfo}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventPriceInfoPut>>, TError,{eventId: string;data: EventPriceInfo}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventPriceInfoPut>>, {eventId: string;data: EventPriceInfo}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventPriceInfoPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventPriceInfoPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventPriceInfoPut>>>
    export type EventPriceInfoPutMutationBody = EventPriceInfo
    export type EventPriceInfoPutMutationError = AxiosError<EventPriceInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary priceInfo - update
 */
export const useEventPriceInfoPut = <TError = AxiosError<EventPriceInfoPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventPriceInfoPut>>, TError,{eventId: string;data: EventPriceInfo}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventPriceInfoPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the general status on the top level of the event with the given `eventId`.

The status of any subEvents that the event has will also be updated to match the general status.
 * @summary status - update
 */
export const eventStatusPut = (
    eventId: string,
    eventStatus: EventStatus, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/status`,
      eventStatus,options
    );
  }



export const getEventStatusPutMutationOptions = <TError = AxiosError<EventStatusPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventStatusPut>>, TError,{eventId: string;data: EventStatus}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventStatusPut>>, TError,{eventId: string;data: EventStatus}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventStatusPut>>, {eventId: string;data: EventStatus}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventStatusPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventStatusPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventStatusPut>>>
    export type EventStatusPutMutationBody = EventStatus
    export type EventStatusPutMutationError = AxiosError<EventStatusPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary status - update
 */
export const useEventStatusPut = <TError = AxiosError<EventStatusPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventStatusPut>>, TError,{eventId: string;data: EventStatus}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventStatusPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the given subEvents on the event with the given `eventId`.

Allows partial updates, omitted properties will be ignored and remain unchanged. Omitted subEvents will also remain unchanged.

Every subEvent to update requires an `id` property that is an integer that corresponds to their index in the list of subEvents on the parent event. For example `0` for the first subEvent, `1` for the second subEvent, and so on.

<!-- theme: warning -->

> Note! If you change the `startDate` of a subEvent, the subEvents will be re-ordered on the parent event afterwards because subEvents are always sorted chronologically.

Only events with calendar type `single` and `multiple` have subEvents, so only events with those calendar types support this endpoint.
 * @summary subEvent - patch
 */
export const eventSubEventPatch = (
    eventId: string,
    eventSubEventPatch: EventSubEventPatch, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.patch(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/sub-events`,
      eventSubEventPatch,options
    );
  }



export const getEventSubEventPatchMutationOptions = <TError = AxiosError<EventSubEventPatch400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventSubEventPatch>>, TError,{eventId: string;data: EventSubEventPatch}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventSubEventPatch>>, TError,{eventId: string;data: EventSubEventPatch}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventSubEventPatch>>, {eventId: string;data: EventSubEventPatch}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventSubEventPatch(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventSubEventPatchMutationResult = NonNullable<Awaited<ReturnType<typeof eventSubEventPatch>>>
    export type EventSubEventPatchMutationBody = EventSubEventPatch
    export type EventSubEventPatchMutationError = AxiosError<EventSubEventPatch400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary subEvent - patch
 */
export const useEventSubEventPatch = <TError = AxiosError<EventSubEventPatch400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventSubEventPatch>>, TError,{eventId: string;data: EventSubEventPatch}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventSubEventPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the event's type (examples of types are `Concert`, `Opendeurdag`, `Lessenreeks`, and so on) based on the given `eventId` and `termId`.

Terms are pre-defined and can be found using our [guide about taxonomy terms](../docs/taxonomy-api/terms.md). Only terms from the `eventtype` domain can be used as event types.

If the `eventId` does not exist a `404 Not Found` will be returned. If the `termId` does not exist or is not a term in the `eventtype` domain, a `400 Bad Request` will be returned. If the request is successful a `204 No Content` will be returned.
 * @summary terms > eventtype - update
 */
export const eventTermsEventtypePut = (
    eventId: string,
    termId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/type/${termId}`,undefined,options
    );
  }



export const getEventTermsEventtypePutMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTermsEventtypePut>>, TError,{eventId: string;termId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventTermsEventtypePut>>, TError,{eventId: string;termId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventTermsEventtypePut>>, {eventId: string;termId: string}> = (props) => {
          const {eventId,termId} = props ?? {};

          return  eventTermsEventtypePut(eventId,termId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventTermsEventtypePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventTermsEventtypePut>>>
    
    export type EventTermsEventtypePutMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary terms > eventtype - update
 */
export const useEventTermsEventtypePut = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTermsEventtypePut>>, TError,{eventId: string;termId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventTermsEventtypePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Deletes the event's current theme based on the given `eventId`.

If the `eventId` does not exist a `404 Not Found` will be returned. If the request is successful a `204 No Content` will be returned.
 * @summary terms > theme - delete
 */
export const eventTermsThemeDelete = (
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/theme`,options
    );
  }



export const getEventTermsThemeDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTermsThemeDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventTermsThemeDelete>>, TError,{eventId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventTermsThemeDelete>>, {eventId: string}> = (props) => {
          const {eventId} = props ?? {};

          return  eventTermsThemeDelete(eventId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventTermsThemeDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventTermsThemeDelete>>>
    
    export type EventTermsThemeDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary terms > theme - delete
 */
export const useEventTermsThemeDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTermsThemeDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventTermsThemeDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the event's theme (examples of themes are `Audiovisuele kunst`, `Moderne dans`, `Actie en avontuur`, and so on) based on the given `eventId` and `termId`.

Terms are pre-defined and can be found using our [guide about taxonomy terms](../docs/taxonomy-api/terms.md). Only terms from the `theme` domain can be used as theme.

If the `eventId` does not exist a `404 Not Found` will be returned. If the `termId` does not exist or is not a term in the `theme` domain, a `400 Bad Request` will be returned. If the request is successful a `204 No Content` will be returned.
 * @summary terms > theme - update
 */
export const eventTermsThemePut = (
    eventId: string,
    termId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/theme/${termId}`,undefined,options
    );
  }



export const getEventTermsThemePutMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTermsThemePut>>, TError,{eventId: string;termId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventTermsThemePut>>, TError,{eventId: string;termId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventTermsThemePut>>, {eventId: string;termId: string}> = (props) => {
          const {eventId,termId} = props ?? {};

          return  eventTermsThemePut(eventId,termId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventTermsThemePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventTermsThemePut>>>
    
    export type EventTermsThemePutMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary terms > theme - update
 */
export const useEventTermsThemePut = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTermsThemePut>>, TError,{eventId: string;termId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventTermsThemePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Deletes the age range from an event.
 * @summary typicalAgeRange - delete
 */
export const eventTypicalAgeRangeDelete = (
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/typical-age-range`,options
    );
  }



export const getEventTypicalAgeRangeDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTypicalAgeRangeDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventTypicalAgeRangeDelete>>, TError,{eventId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventTypicalAgeRangeDelete>>, {eventId: string}> = (props) => {
          const {eventId} = props ?? {};

          return  eventTypicalAgeRangeDelete(eventId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventTypicalAgeRangeDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventTypicalAgeRangeDelete>>>
    
    export type EventTypicalAgeRangeDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary typicalAgeRange - delete
 */
export const useEventTypicalAgeRangeDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTypicalAgeRangeDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventTypicalAgeRangeDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the age range of the event with the given `eventId`.
 * @summary typicalAgeRange - update
 */
export const eventTypicalAgeRangePut = (
    eventId: string,
    eventTypicalAgeRangePut: EventTypicalAgeRangePut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/typical-age-range`,
      eventTypicalAgeRangePut,options
    );
  }



export const getEventTypicalAgeRangePutMutationOptions = <TError = AxiosError<EventTypicalAgeRangePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTypicalAgeRangePut>>, TError,{eventId: string;data: EventTypicalAgeRangePut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventTypicalAgeRangePut>>, TError,{eventId: string;data: EventTypicalAgeRangePut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventTypicalAgeRangePut>>, {eventId: string;data: EventTypicalAgeRangePut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventTypicalAgeRangePut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventTypicalAgeRangePutMutationResult = NonNullable<Awaited<ReturnType<typeof eventTypicalAgeRangePut>>>
    export type EventTypicalAgeRangePutMutationBody = EventTypicalAgeRangePut
    export type EventTypicalAgeRangePutMutationError = AxiosError<EventTypicalAgeRangePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary typicalAgeRange - update
 */
export const useEventTypicalAgeRangePut = <TError = AxiosError<EventTypicalAgeRangePut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventTypicalAgeRangePut>>, TError,{eventId: string;data: EventTypicalAgeRangePut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventTypicalAgeRangePutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Add a video as a URL reference to an event

The video objects contains:

* `url`: The full URL of the video. Currently only *Vimeo* and *Youtube* are supported as video source locations.
* `copyrightHolder`: The copyright holder of the video material. Although this field is optional it is strongly recommended to add a reference to the entity owning the rights on the video material.
 * @summary videos - add
 */
export const eventVideosPost = (
    eventId: string,
    eventVideosPost: EventVideosPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventVideosPost200>> => {
    
    return axios.post(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/videos`,
      eventVideosPost,options
    );
  }



export const getEventVideosPostMutationOptions = <TError = AxiosError<EventVideosPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventVideosPost>>, TError,{eventId: string;data: EventVideosPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventVideosPost>>, TError,{eventId: string;data: EventVideosPost}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventVideosPost>>, {eventId: string;data: EventVideosPost}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventVideosPost(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventVideosPostMutationResult = NonNullable<Awaited<ReturnType<typeof eventVideosPost>>>
    export type EventVideosPostMutationBody = EventVideosPost
    export type EventVideosPostMutationError = AxiosError<EventVideosPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary videos - add
 */
export const useEventVideosPost = <TError = AxiosError<EventVideosPost400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventVideosPost>>, TError,{eventId: string;data: EventVideosPost}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventVideosPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Update one or more videos of an event.

The video object(s) must contain

* `id`: The id of the video object to be changed.

The video object(s) can contain:

* `url`: The full URL of the video. Currently only *Vimeo* and *Youtube* are supported as video source locations.
* `language`: The updated language of a video
* `copyrightHolder`: The copyright holder of the video material. Although this field is optional it is strongly recommended to add a reference to the entity owning the rights on the video material.
 * @summary videos - patch
 */
export const eventVideosPatch = (
    eventId: string,
    eventVideosPatch: EventVideosPatch, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.patch(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/videos`,
      eventVideosPatch,options
    );
  }



export const getEventVideosPatchMutationOptions = <TError = AxiosError<EventVideosPatch400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventVideosPatch>>, TError,{eventId: string;data: EventVideosPatch}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventVideosPatch>>, TError,{eventId: string;data: EventVideosPatch}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventVideosPatch>>, {eventId: string;data: EventVideosPatch}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventVideosPatch(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventVideosPatchMutationResult = NonNullable<Awaited<ReturnType<typeof eventVideosPatch>>>
    export type EventVideosPatchMutationBody = EventVideosPatch
    export type EventVideosPatchMutationError = AxiosError<EventVideosPatch400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary videos - patch
 */
export const useEventVideosPatch = <TError = AxiosError<EventVideosPatch400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventVideosPatch>>, TError,{eventId: string;data: EventVideosPatch}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventVideosPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Delete an embedded video from an event based on the event id and the video id.
 * @summary videos - delete
 */
export const eventVideosDelete = (
    eventId: string,
    videoId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/videos/${videoId}`,options
    );
  }



export const getEventVideosDeleteMutationOptions = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventVideosDelete>>, TError,{eventId: string;videoId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventVideosDelete>>, TError,{eventId: string;videoId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventVideosDelete>>, {eventId: string;videoId: string}> = (props) => {
          const {eventId,videoId} = props ?? {};

          return  eventVideosDelete(eventId,videoId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventVideosDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventVideosDelete>>>
    
    export type EventVideosDeleteMutationError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary videos - delete
 */
export const useEventVideosDelete = <TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventVideosDelete>>, TError,{eventId: string;videoId: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventVideosDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Updates the workflow status of an event. Possible statuses are:

- `DRAFT`: The default status of new events. Events with this status do not appear in online calendars like <https://www.uitinvlaanderen.be> or the search on <https://www.uitdatabank.be>
- `READY_FOR_VALIDATION`: This status means the event has been published, but not approved yet. Most online calendars will already show it, and it will appear in the search on <https://www.uitdatabank.be>
- `APPROVED`: The event has been approved by a moderator. It will appear on all online calendars. You cannot set this status unless you have moderation permissions.
- `REJECTED`: The event has been rejected by a moderator. It will not appear on any online calendars. You cannot set this status unless you have moderation permissions.
- `DELETED`: The event has been deleted. It will not appear on any online calendars.
 * @summary workflowStatus - update
 */
export const eventWorkflowStatusPut = (
    eventId: string,
    eventWorkflowStatusPut: EventWorkflowStatusPut, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `NEXT_PUBLIC_ENTRY_API_PATH/events/${eventId}/workflow-status`,
      eventWorkflowStatusPut,options
    );
  }



export const getEventWorkflowStatusPutMutationOptions = <TError = AxiosError<EventWorkflowStatusPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventWorkflowStatusPut>>, TError,{eventId: string;data: EventWorkflowStatusPut}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventWorkflowStatusPut>>, TError,{eventId: string;data: EventWorkflowStatusPut}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventWorkflowStatusPut>>, {eventId: string;data: EventWorkflowStatusPut}> = (props) => {
          const {eventId,data} = props ?? {};

          return  eventWorkflowStatusPut(eventId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type EventWorkflowStatusPutMutationResult = NonNullable<Awaited<ReturnType<typeof eventWorkflowStatusPut>>>
    export type EventWorkflowStatusPutMutationBody = EventWorkflowStatusPut
    export type EventWorkflowStatusPutMutationError = AxiosError<EventWorkflowStatusPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>

    /**
 * @summary workflowStatus - update
 */
export const useEventWorkflowStatusPut = <TError = AxiosError<EventWorkflowStatusPut400 | UnauthorizedResponse | ForbiddenResponse | NotFoundResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventWorkflowStatusPut>>, TError,{eventId: string;data: EventWorkflowStatusPut}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getEventWorkflowStatusPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    